"""
automatically generated by vgrad/tools/spirv_generator.py from ../SPIRV-Headers/include/spirv/unified1/spirv.core.grammar.json version 1.6.4
"""
from enum import IntFlag, IntEnum
from vgrad.spirv_base import SpirvInstruction
from typing import Optional


SPIRV_MAGIC_NUMBER = 0x07230203


class ImageOperands(IntFlag):
    Bias = 0x0001
    Lod = 0x0002
    Grad = 0x0004
    ConstOffset = 0x0008
    Offset = 0x0010
    ConstOffsets = 0x0020
    Sample = 0x0040
    MinLod = 0x0080
    MakeTexelAvailable = 0x0100
    MakeTexelAvailableKHR = 0x0100
    MakeTexelVisible = 0x0200
    MakeTexelVisibleKHR = 0x0200
    NonPrivateTexel = 0x0400
    NonPrivateTexelKHR = 0x0400
    VolatileTexel = 0x0800
    VolatileTexelKHR = 0x0800
    SignExtend = 0x1000
    ZeroExtend = 0x2000
    Nontemporal = 0x4000
    Offsets = 0x10000


class FPFastMathMode(IntFlag):
    NotNaN = 0x0001
    NotInf = 0x0002
    NSZ = 0x0004
    AllowRecip = 0x0008
    Fast = 0x0010
    AllowContract = 0x10000
    AllowContractFastINTEL = 0x10000
    AllowReassoc = 0x20000
    AllowReassocINTEL = 0x20000
    AllowTransform = 0x40000


class SelectionControl(IntFlag):
    Flatten = 0x0001
    DontFlatten = 0x0002


class LoopControl(IntFlag):
    Unroll = 0x0001
    DontUnroll = 0x0002
    DependencyInfinite = 0x0004
    DependencyLength = 0x0008
    MinIterations = 0x0010
    MaxIterations = 0x0020
    IterationMultiple = 0x0040
    PeelCount = 0x0080
    PartialCount = 0x0100
    InitiationIntervalINTEL = 0x10000
    MaxConcurrencyINTEL = 0x20000
    DependencyArrayINTEL = 0x40000
    PipelineEnableINTEL = 0x80000
    LoopCoalesceINTEL = 0x100000
    MaxInterleavingINTEL = 0x200000
    SpeculatedIterationsINTEL = 0x400000
    NoFusionINTEL = 0x800000
    LoopCountINTEL = 0x1000000
    MaxReinvocationDelayINTEL = 0x2000000


class FunctionControl(IntFlag):
    Inline = 0x0001
    DontInline = 0x0002
    Pure = 0x0004
    Const = 0x0008
    OptNoneEXT = 0x10000
    OptNoneINTEL = 0x10000


class MemorySemantics(IntFlag):
    Relaxed = 0x0000
    _None = 0x0000
    Acquire = 0x0002
    Release = 0x0004
    AcquireRelease = 0x0008
    SequentiallyConsistent = 0x0010
    UniformMemory = 0x0040
    SubgroupMemory = 0x0080
    WorkgroupMemory = 0x0100
    CrossWorkgroupMemory = 0x0200
    AtomicCounterMemory = 0x0400
    ImageMemory = 0x0800
    OutputMemory = 0x1000
    OutputMemoryKHR = 0x1000
    MakeAvailable = 0x2000
    MakeAvailableKHR = 0x2000
    MakeVisible = 0x4000
    MakeVisibleKHR = 0x4000
    Volatile = 0x8000


class MemoryAccess(IntFlag):
    Volatile = 0x0001
    Aligned = 0x0002
    Nontemporal = 0x0004
    MakePointerAvailable = 0x0008
    MakePointerAvailableKHR = 0x0008
    MakePointerVisible = 0x0010
    MakePointerVisibleKHR = 0x0010
    NonPrivatePointer = 0x0020
    NonPrivatePointerKHR = 0x0020
    AliasScopeINTELMask = 0x10000
    NoAliasINTELMask = 0x20000


class KernelProfilingInfo(IntFlag):
    CmdExecTime = 0x0001


class RayFlags(IntFlag):
    NoneKHR = 0x0000
    OpaqueKHR = 0x0001
    NoOpaqueKHR = 0x0002
    TerminateOnFirstHitKHR = 0x0004
    SkipClosestHitShaderKHR = 0x0008
    CullBackFacingTrianglesKHR = 0x0010
    CullFrontFacingTrianglesKHR = 0x0020
    CullOpaqueKHR = 0x0040
    CullNoOpaqueKHR = 0x0080
    SkipTrianglesKHR = 0x0100
    SkipBuiltinPrimitivesNV = 0x0100
    SkipAABBsKHR = 0x0200
    ForceOpacityMicromap2StateEXT = 0x0400


class FragmentShadingRate(IntFlag):
    Vertical2Pixels = 0x0001
    Vertical4Pixels = 0x0002
    Horizontal2Pixels = 0x0004
    Horizontal4Pixels = 0x0008


class RawAccessChainOperands(IntFlag):
    RobustnessPerComponentNV = 0x0001
    RobustnessPerElementNV = 0x0002


class SourceLanguage(IntEnum):
    Unknown = 0
    ESSL = 1
    GLSL = 2
    OpenCL_C = 3
    OpenCL_CPP = 4
    HLSL = 5
    CPP_for_OpenCL = 6
    SYCL = 7
    HERO_C = 8
    NZSL = 9
    WGSL = 10
    Slang = 11
    Zig = 12
    Rust = 13


class ExecutionModel(IntEnum):
    Vertex = 0
    TessellationControl = 1
    TessellationEvaluation = 2
    Geometry = 3
    Fragment = 4
    GLCompute = 5
    Kernel = 6
    TaskNV = 5267
    MeshNV = 5268
    RayGenerationKHR = 5313
    IntersectionKHR = 5314
    AnyHitKHR = 5315
    ClosestHitKHR = 5316
    MissKHR = 5317
    CallableKHR = 5318
    TaskEXT = 5364
    MeshEXT = 5365


class AddressingModel(IntEnum):
    Logical = 0
    Physical32 = 1
    Physical64 = 2
    PhysicalStorageBuffer64 = 5348


class MemoryModel(IntEnum):
    Simple = 0
    GLSL450 = 1
    OpenCL = 2
    Vulkan = 3


class ExecutionMode(IntEnum):
    Invocations = 0
    SpacingEqual = 1
    SpacingFractionalEven = 2
    SpacingFractionalOdd = 3
    VertexOrderCw = 4
    VertexOrderCcw = 5
    PixelCenterInteger = 6
    OriginUpperLeft = 7
    OriginLowerLeft = 8
    EarlyFragmentTests = 9
    PointMode = 10
    Xfb = 11
    DepthReplacing = 12
    DepthGreater = 14
    DepthLess = 15
    DepthUnchanged = 16
    LocalSize = 17
    LocalSizeHint = 18
    InputPoints = 19
    InputLines = 20
    InputLinesAdjacency = 21
    Triangles = 22
    InputTrianglesAdjacency = 23
    Quads = 24
    Isolines = 25
    OutputVertices = 26
    OutputPoints = 27
    OutputLineStrip = 28
    OutputTriangleStrip = 29
    VecTypeHint = 30
    ContractionOff = 31
    Initializer = 33
    Finalizer = 34
    SubgroupSize = 35
    SubgroupsPerWorkgroup = 36
    SubgroupsPerWorkgroupId = 37
    LocalSizeId = 38
    LocalSizeHintId = 39
    NonCoherentColorAttachmentReadEXT = 4169
    NonCoherentDepthAttachmentReadEXT = 4170
    NonCoherentStencilAttachmentReadEXT = 4171
    SubgroupUniformControlFlowKHR = 4421
    PostDepthCoverage = 4446
    DenormPreserve = 4459
    DenormFlushToZero = 4460
    SignedZeroInfNanPreserve = 4461
    RoundingModeRTE = 4462
    RoundingModeRTZ = 4463
    NonCoherentTileAttachmentReadQCOM = 4489
    TileShadingRateQCOM = 4490
    EarlyAndLateFragmentTestsAMD = 5017
    StencilRefReplacingEXT = 5027
    CoalescingAMDX = 5069
    IsApiEntryAMDX = 5070
    MaxNodeRecursionAMDX = 5071
    StaticNumWorkgroupsAMDX = 5072
    ShaderIndexAMDX = 5073
    MaxNumWorkgroupsAMDX = 5077
    StencilRefUnchangedFrontAMD = 5079
    StencilRefGreaterFrontAMD = 5080
    StencilRefLessFrontAMD = 5081
    StencilRefUnchangedBackAMD = 5082
    StencilRefGreaterBackAMD = 5083
    StencilRefLessBackAMD = 5084
    QuadDerivativesKHR = 5088
    RequireFullQuadsKHR = 5089
    SharesInputWithAMDX = 5102
    OutputLinesEXT = 5269
    OutputPrimitivesEXT = 5270
    DerivativeGroupQuadsKHR = 5289
    DerivativeGroupLinearKHR = 5290
    OutputTrianglesEXT = 5298
    PixelInterlockOrderedEXT = 5366
    PixelInterlockUnorderedEXT = 5367
    SampleInterlockOrderedEXT = 5368
    SampleInterlockUnorderedEXT = 5369
    ShadingRateInterlockOrderedEXT = 5370
    ShadingRateInterlockUnorderedEXT = 5371
    SharedLocalMemorySizeINTEL = 5618
    RoundingModeRTPINTEL = 5620
    RoundingModeRTNINTEL = 5621
    FloatingPointModeALTINTEL = 5622
    FloatingPointModeIEEEINTEL = 5623
    MaxWorkgroupSizeINTEL = 5893
    MaxWorkDimINTEL = 5894
    NoGlobalOffsetINTEL = 5895
    NumSIMDWorkitemsINTEL = 5896
    SchedulerTargetFmaxMhzINTEL = 5903
    MaximallyReconvergesKHR = 6023
    FPFastMathDefault = 6028
    StreamingInterfaceINTEL = 6154
    RegisterMapInterfaceINTEL = 6160
    NamedBarrierCountINTEL = 6417
    MaximumRegistersINTEL = 6461
    MaximumRegistersIdINTEL = 6462
    NamedMaximumRegistersINTEL = 6463


class StorageClass(IntEnum):
    UniformConstant = 0
    Input = 1
    Uniform = 2
    Output = 3
    Workgroup = 4
    CrossWorkgroup = 5
    Private = 6
    Function = 7
    Generic = 8
    PushConstant = 9
    AtomicCounter = 10
    Image = 11
    StorageBuffer = 12
    TileImageEXT = 4172
    TileAttachmentQCOM = 4491
    NodePayloadAMDX = 5068
    CallableDataKHR = 5328
    IncomingCallableDataKHR = 5329
    RayPayloadKHR = 5338
    HitAttributeKHR = 5339
    IncomingRayPayloadKHR = 5342
    ShaderRecordBufferKHR = 5343
    PhysicalStorageBuffer = 5349
    HitObjectAttributeNV = 5385
    TaskPayloadWorkgroupEXT = 5402
    CodeSectionINTEL = 5605
    DeviceOnlyINTEL = 5936
    HostOnlyINTEL = 5937


class Dim(IntEnum):
    _1D = 0
    _2D = 1
    _3D = 2
    Cube = 3
    Rect = 4
    Buffer = 5
    SubpassData = 6
    TileImageDataEXT = 4173


class SamplerAddressingMode(IntEnum):
    _None = 0
    ClampToEdge = 1
    Clamp = 2
    Repeat = 3
    RepeatMirrored = 4


class SamplerFilterMode(IntEnum):
    Nearest = 0
    Linear = 1


class ImageFormat(IntEnum):
    Unknown = 0
    Rgba32f = 1
    Rgba16f = 2
    R32f = 3
    Rgba8 = 4
    Rgba8Snorm = 5
    Rg32f = 6
    Rg16f = 7
    R11fG11fB10f = 8
    R16f = 9
    Rgba16 = 10
    Rgb10A2 = 11
    Rg16 = 12
    Rg8 = 13
    R16 = 14
    R8 = 15
    Rgba16Snorm = 16
    Rg16Snorm = 17
    Rg8Snorm = 18
    R16Snorm = 19
    R8Snorm = 20
    Rgba32i = 21
    Rgba16i = 22
    Rgba8i = 23
    R32i = 24
    Rg32i = 25
    Rg16i = 26
    Rg8i = 27
    R16i = 28
    R8i = 29
    Rgba32ui = 30
    Rgba16ui = 31
    Rgba8ui = 32
    R32ui = 33
    Rgb10a2ui = 34
    Rg32ui = 35
    Rg16ui = 36
    Rg8ui = 37
    R16ui = 38
    R8ui = 39
    R64ui = 40
    R64i = 41


class ImageChannelOrder(IntEnum):
    R = 0
    A = 1
    RG = 2
    RA = 3
    RGB = 4
    RGBA = 5
    BGRA = 6
    ARGB = 7
    Intensity = 8
    Luminance = 9
    Rx = 10
    RGx = 11
    RGBx = 12
    Depth = 13
    DepthStencil = 14
    sRGB = 15
    sRGBx = 16
    sRGBA = 17
    sBGRA = 18
    ABGR = 19


class ImageChannelDataType(IntEnum):
    SnormInt8 = 0
    SnormInt16 = 1
    UnormInt8 = 2
    UnormInt16 = 3
    UnormShort565 = 4
    UnormShort555 = 5
    UnormInt101010 = 6
    SignedInt8 = 7
    SignedInt16 = 8
    SignedInt32 = 9
    UnsignedInt8 = 10
    UnsignedInt16 = 11
    UnsignedInt32 = 12
    HalfFloat = 13
    Float = 14
    UnormInt24 = 15
    UnormInt101010_2 = 16
    UnormInt10X6EXT = 17
    UnsignedIntRaw10EXT = 19
    UnsignedIntRaw12EXT = 20
    UnormInt2_101010EXT = 21
    UnsignedInt10X6EXT = 22
    UnsignedInt12X4EXT = 23
    UnsignedInt14X2EXT = 24
    UnormInt12X4EXT = 25
    UnormInt14X2EXT = 26


class FPRoundingMode(IntEnum):
    RTE = 0
    RTZ = 1
    RTP = 2
    RTN = 3


class FPDenormMode(IntEnum):
    Preserve = 0
    FlushToZero = 1


class QuantizationModes(IntEnum):
    TRN = 0
    TRN_ZERO = 1
    RND = 2
    RND_ZERO = 3
    RND_INF = 4
    RND_MIN_INF = 5
    RND_CONV = 6
    RND_CONV_ODD = 7


class FPOperationMode(IntEnum):
    IEEE = 0
    ALT = 1


class OverflowModes(IntEnum):
    WRAP = 0
    SAT = 1
    SAT_ZERO = 2
    SAT_SYM = 3


class LinkageType(IntEnum):
    Export = 0
    Import = 1
    LinkOnceODR = 2


class AccessQualifier(IntEnum):
    ReadOnly = 0
    WriteOnly = 1
    ReadWrite = 2


class HostAccessQualifier(IntEnum):
    NoneINTEL = 0
    ReadINTEL = 1
    WriteINTEL = 2
    ReadWriteINTEL = 3


class FunctionParameterAttribute(IntEnum):
    Zext = 0
    Sext = 1
    ByVal = 2
    Sret = 3
    NoAlias = 4
    NoCapture = 5
    NoWrite = 6
    NoReadWrite = 7
    RuntimeAlignedINTEL = 5940


class Decoration(IntEnum):
    RelaxedPrecision = 0
    SpecId = 1
    Block = 2
    BufferBlock = 3
    RowMajor = 4
    ColMajor = 5
    ArrayStride = 6
    MatrixStride = 7
    GLSLShared = 8
    GLSLPacked = 9
    CPacked = 10
    BuiltIn = 11
    NoPerspective = 13
    Flat = 14
    Patch = 15
    Centroid = 16
    Sample = 17
    Invariant = 18
    Restrict = 19
    Aliased = 20
    Volatile = 21
    Constant = 22
    Coherent = 23
    NonWritable = 24
    NonReadable = 25
    Uniform = 26
    UniformId = 27
    SaturatedConversion = 28
    Stream = 29
    Location = 30
    Component = 31
    Index = 32
    Binding = 33
    DescriptorSet = 34
    Offset = 35
    XfbBuffer = 36
    XfbStride = 37
    FuncParamAttr = 38
    FPRoundingMode = 39
    FPFastMathMode = 40
    LinkageAttributes = 41
    NoContraction = 42
    InputAttachmentIndex = 43
    Alignment = 44
    MaxByteOffset = 45
    AlignmentId = 46
    MaxByteOffsetId = 47
    SaturatedToLargestFloat8NormalConversionEXT = 4216
    NoSignedWrap = 4469
    NoUnsignedWrap = 4470
    WeightTextureQCOM = 4487
    BlockMatchTextureQCOM = 4488
    BlockMatchSamplerQCOM = 4499
    ExplicitInterpAMD = 4999
    NodeSharesPayloadLimitsWithAMDX = 5019
    NodeMaxPayloadsAMDX = 5020
    TrackFinishWritingAMDX = 5078
    PayloadNodeNameAMDX = 5091
    PayloadNodeBaseIndexAMDX = 5098
    PayloadNodeSparseArrayAMDX = 5099
    PayloadNodeArraySizeAMDX = 5100
    PayloadDispatchIndirectAMDX = 5105
    OverrideCoverageNV = 5248
    PassthroughNV = 5250
    ViewportRelativeNV = 5252
    SecondaryViewportRelativeNV = 5256
    PerPrimitiveEXT = 5271
    PerViewNV = 5272
    PerTaskNV = 5273
    PerVertexKHR = 5285
    NonUniform = 5300
    RestrictPointer = 5355
    AliasedPointer = 5356
    HitObjectShaderRecordBufferNV = 5386
    BindlessSamplerNV = 5398
    BindlessImageNV = 5399
    BoundSamplerNV = 5400
    BoundImageNV = 5401
    SIMTCallINTEL = 5599
    ReferencedIndirectlyINTEL = 5602
    ClobberINTEL = 5607
    SideEffectsINTEL = 5608
    VectorComputeVariableINTEL = 5624
    FuncParamIOKindINTEL = 5625
    VectorComputeFunctionINTEL = 5626
    StackCallINTEL = 5627
    GlobalVariableOffsetINTEL = 5628
    CounterBuffer = 5634
    UserSemantic = 5635
    UserTypeGOOGLE = 5636
    FunctionRoundingModeINTEL = 5822
    FunctionDenormModeINTEL = 5823
    RegisterINTEL = 5825
    MemoryINTEL = 5826
    NumbanksINTEL = 5827
    BankwidthINTEL = 5828
    MaxPrivateCopiesINTEL = 5829
    SinglepumpINTEL = 5830
    DoublepumpINTEL = 5831
    MaxReplicatesINTEL = 5832
    SimpleDualPortINTEL = 5833
    MergeINTEL = 5834
    BankBitsINTEL = 5835
    ForcePow2DepthINTEL = 5836
    StridesizeINTEL = 5883
    WordsizeINTEL = 5884
    TrueDualPortINTEL = 5885
    BurstCoalesceINTEL = 5899
    CacheSizeINTEL = 5900
    DontStaticallyCoalesceINTEL = 5901
    PrefetchINTEL = 5902
    StallEnableINTEL = 5905
    FuseLoopsInFunctionINTEL = 5907
    MathOpDSPModeINTEL = 5909
    AliasScopeINTEL = 5914
    NoAliasINTEL = 5915
    InitiationIntervalINTEL = 5917
    MaxConcurrencyINTEL = 5918
    PipelineEnableINTEL = 5919
    BufferLocationINTEL = 5921
    IOPipeStorageINTEL = 5944
    FunctionFloatingPointModeINTEL = 6080
    SingleElementVectorINTEL = 6085
    VectorComputeCallableFunctionINTEL = 6087
    MediaBlockIOINTEL = 6140
    StallFreeINTEL = 6151
    FPMaxErrorDecorationINTEL = 6170
    LatencyControlLabelINTEL = 6172
    LatencyControlConstraintINTEL = 6173
    ConduitKernelArgumentINTEL = 6175
    RegisterMapKernelArgumentINTEL = 6176
    MMHostInterfaceAddressWidthINTEL = 6177
    MMHostInterfaceDataWidthINTEL = 6178
    MMHostInterfaceLatencyINTEL = 6179
    MMHostInterfaceReadWriteModeINTEL = 6180
    MMHostInterfaceMaxBurstINTEL = 6181
    MMHostInterfaceWaitRequestINTEL = 6182
    StableKernelArgumentINTEL = 6183
    HostAccessINTEL = 6188
    InitModeINTEL = 6190
    ImplementInRegisterMapINTEL = 6191
    ConditionalINTEL = 6247
    CacheControlLoadINTEL = 6442
    CacheControlStoreINTEL = 6443


class BuiltIn(IntEnum):
    Position = 0
    PointSize = 1
    ClipDistance = 3
    CullDistance = 4
    VertexId = 5
    InstanceId = 6
    PrimitiveId = 7
    InvocationId = 8
    Layer = 9
    ViewportIndex = 10
    TessLevelOuter = 11
    TessLevelInner = 12
    TessCoord = 13
    PatchVertices = 14
    FragCoord = 15
    PointCoord = 16
    FrontFacing = 17
    SampleId = 18
    SamplePosition = 19
    SampleMask = 20
    FragDepth = 22
    HelperInvocation = 23
    NumWorkgroups = 24
    WorkgroupSize = 25
    WorkgroupId = 26
    LocalInvocationId = 27
    GlobalInvocationId = 28
    LocalInvocationIndex = 29
    WorkDim = 30
    GlobalSize = 31
    EnqueuedWorkgroupSize = 32
    GlobalOffset = 33
    GlobalLinearId = 34
    SubgroupSize = 36
    SubgroupMaxSize = 37
    NumSubgroups = 38
    NumEnqueuedSubgroups = 39
    SubgroupId = 40
    SubgroupLocalInvocationId = 41
    VertexIndex = 42
    InstanceIndex = 43
    CoreIDARM = 4160
    CoreCountARM = 4161
    CoreMaxIDARM = 4162
    WarpIDARM = 4163
    WarpMaxIDARM = 4164
    SubgroupEqMask = 4416
    SubgroupGeMask = 4417
    SubgroupGtMask = 4418
    SubgroupLeMask = 4419
    SubgroupLtMask = 4420
    BaseVertex = 4424
    BaseInstance = 4425
    DrawIndex = 4426
    PrimitiveShadingRateKHR = 4432
    DeviceIndex = 4438
    ViewIndex = 4440
    ShadingRateKHR = 4444
    TileOffsetQCOM = 4492
    TileDimensionQCOM = 4493
    TileApronSizeQCOM = 4494
    BaryCoordNoPerspAMD = 4992
    BaryCoordNoPerspCentroidAMD = 4993
    BaryCoordNoPerspSampleAMD = 4994
    BaryCoordSmoothAMD = 4995
    BaryCoordSmoothCentroidAMD = 4996
    BaryCoordSmoothSampleAMD = 4997
    BaryCoordPullModelAMD = 4998
    FragStencilRefEXT = 5014
    RemainingRecursionLevelsAMDX = 5021
    ShaderIndexAMDX = 5073
    ViewportMaskNV = 5253
    SecondaryPositionNV = 5257
    SecondaryViewportMaskNV = 5258
    PositionPerViewNV = 5261
    ViewportMaskPerViewNV = 5262
    FullyCoveredEXT = 5264
    TaskCountNV = 5274
    PrimitiveCountNV = 5275
    PrimitiveIndicesNV = 5276
    ClipDistancePerViewNV = 5277
    CullDistancePerViewNV = 5278
    LayerPerViewNV = 5279
    MeshViewCountNV = 5280
    MeshViewIndicesNV = 5281
    BaryCoordKHR = 5286
    BaryCoordNoPerspKHR = 5287
    FragSizeEXT = 5292
    FragInvocationCountEXT = 5293
    PrimitivePointIndicesEXT = 5294
    PrimitiveLineIndicesEXT = 5295
    PrimitiveTriangleIndicesEXT = 5296
    CullPrimitiveEXT = 5299
    LaunchIdKHR = 5319
    LaunchSizeKHR = 5320
    WorldRayOriginKHR = 5321
    WorldRayDirectionKHR = 5322
    ObjectRayOriginKHR = 5323
    ObjectRayDirectionKHR = 5324
    RayTminKHR = 5325
    RayTmaxKHR = 5326
    InstanceCustomIndexKHR = 5327
    ObjectToWorldKHR = 5330
    WorldToObjectKHR = 5331
    HitTNV = 5332
    HitKindKHR = 5333
    CurrentRayTimeNV = 5334
    HitTriangleVertexPositionsKHR = 5335
    HitMicroTriangleVertexPositionsNV = 5337
    HitMicroTriangleVertexBarycentricsNV = 5344
    IncomingRayFlagsKHR = 5351
    RayGeometryIndexKHR = 5352
    HitIsSphereNV = 5359
    HitIsLSSNV = 5360
    HitSpherePositionNV = 5361
    WarpsPerSMNV = 5374
    SMCountNV = 5375
    WarpIDNV = 5376
    SMIDNV = 5377
    HitLSSPositionsNV = 5396
    HitKindFrontFacingMicroTriangleNV = 5405
    HitKindBackFacingMicroTriangleNV = 5406
    HitSphereRadiusNV = 5420
    HitLSSRadiiNV = 5421
    ClusterIDNV = 5436
    CullMaskKHR = 6021


class Scope(IntEnum):
    CrossDevice = 0
    Device = 1
    Workgroup = 2
    Subgroup = 3
    Invocation = 4
    QueueFamily = 5
    ShaderCallKHR = 6


class GroupOperation(IntEnum):
    Reduce = 0
    InclusiveScan = 1
    ExclusiveScan = 2
    ClusteredReduce = 3
    PartitionedReduceNV = 6
    PartitionedInclusiveScanNV = 7
    PartitionedExclusiveScanNV = 8


class KernelEnqueueFlags(IntEnum):
    NoWait = 0
    WaitKernel = 1
    WaitWorkGroup = 2


class Capability(IntEnum):
    Matrix = 0
    Shader = 1
    Geometry = 2
    Tessellation = 3
    Addresses = 4
    Linkage = 5
    Kernel = 6
    Vector16 = 7
    Float16Buffer = 8
    Float16 = 9
    Float64 = 10
    Int64 = 11
    Int64Atomics = 12
    ImageBasic = 13
    ImageReadWrite = 14
    ImageMipmap = 15
    Pipes = 17
    Groups = 18
    DeviceEnqueue = 19
    LiteralSampler = 20
    AtomicStorage = 21
    Int16 = 22
    TessellationPointSize = 23
    GeometryPointSize = 24
    ImageGatherExtended = 25
    StorageImageMultisample = 27
    UniformBufferArrayDynamicIndexing = 28
    SampledImageArrayDynamicIndexing = 29
    StorageBufferArrayDynamicIndexing = 30
    StorageImageArrayDynamicIndexing = 31
    ClipDistance = 32
    CullDistance = 33
    ImageCubeArray = 34
    SampleRateShading = 35
    ImageRect = 36
    SampledRect = 37
    GenericPointer = 38
    Int8 = 39
    InputAttachment = 40
    SparseResidency = 41
    MinLod = 42
    Sampled1D = 43
    Image1D = 44
    SampledCubeArray = 45
    SampledBuffer = 46
    ImageBuffer = 47
    ImageMSArray = 48
    StorageImageExtendedFormats = 49
    ImageQuery = 50
    DerivativeControl = 51
    InterpolationFunction = 52
    TransformFeedback = 53
    GeometryStreams = 54
    StorageImageReadWithoutFormat = 55
    StorageImageWriteWithoutFormat = 56
    MultiViewport = 57
    SubgroupDispatch = 58
    NamedBarrier = 59
    PipeStorage = 60
    GroupNonUniform = 61
    GroupNonUniformVote = 62
    GroupNonUniformArithmetic = 63
    GroupNonUniformBallot = 64
    GroupNonUniformShuffle = 65
    GroupNonUniformShuffleRelative = 66
    GroupNonUniformClustered = 67
    GroupNonUniformQuad = 68
    ShaderLayer = 69
    ShaderViewportIndex = 70
    UniformDecoration = 71
    CoreBuiltinsARM = 4165
    TileImageColorReadAccessEXT = 4166
    TileImageDepthReadAccessEXT = 4167
    TileImageStencilReadAccessEXT = 4168
    TensorsARM = 4174
    StorageTensorArrayDynamicIndexingARM = 4175
    StorageTensorArrayNonUniformIndexingARM = 4176
    GraphARM = 4191
    CooperativeMatrixLayoutsARM = 4201
    Float8EXT = 4212
    Float8CooperativeMatrixEXT = 4213
    FragmentShadingRateKHR = 4422
    SubgroupBallotKHR = 4423
    DrawParameters = 4427
    WorkgroupMemoryExplicitLayoutKHR = 4428
    WorkgroupMemoryExplicitLayout8BitAccessKHR = 4429
    WorkgroupMemoryExplicitLayout16BitAccessKHR = 4430
    SubgroupVoteKHR = 4431
    StorageBuffer16BitAccess = 4433
    UniformAndStorageBuffer16BitAccess = 4434
    StoragePushConstant16 = 4435
    StorageInputOutput16 = 4436
    DeviceGroup = 4437
    MultiView = 4439
    VariablePointersStorageBuffer = 4441
    VariablePointers = 4442
    AtomicStorageOps = 4445
    SampleMaskPostDepthCoverage = 4447
    StorageBuffer8BitAccess = 4448
    UniformAndStorageBuffer8BitAccess = 4449
    StoragePushConstant8 = 4450
    DenormPreserve = 4464
    DenormFlushToZero = 4465
    SignedZeroInfNanPreserve = 4466
    RoundingModeRTE = 4467
    RoundingModeRTZ = 4468
    RayQueryProvisionalKHR = 4471
    RayQueryKHR = 4472
    UntypedPointersKHR = 4473
    RayTraversalPrimitiveCullingKHR = 4478
    RayTracingKHR = 4479
    TextureSampleWeightedQCOM = 4484
    TextureBoxFilterQCOM = 4485
    TextureBlockMatchQCOM = 4486
    TileShadingQCOM = 4495
    CooperativeMatrixConversionQCOM = 4496
    TextureBlockMatch2QCOM = 4498
    Float16ImageAMD = 5008
    ImageGatherBiasLodAMD = 5009
    FragmentMaskAMD = 5010
    StencilExportEXT = 5013
    ImageReadWriteLodAMD = 5015
    Int64ImageEXT = 5016
    ShaderClockKHR = 5055
    ShaderEnqueueAMDX = 5067
    QuadControlKHR = 5087
    Int4TypeINTEL = 5112
    Int4CooperativeMatrixINTEL = 5114
    BFloat16TypeKHR = 5116
    BFloat16DotProductKHR = 5117
    BFloat16CooperativeMatrixKHR = 5118
    SampleMaskOverrideCoverageNV = 5249
    GeometryShaderPassthroughNV = 5251
    ShaderViewportIndexLayerEXT = 5254
    ShaderViewportMaskNV = 5255
    ShaderStereoViewNV = 5259
    PerViewAttributesNV = 5260
    FragmentFullyCoveredEXT = 5265
    MeshShadingNV = 5266
    ImageFootprintNV = 5282
    MeshShadingEXT = 5283
    FragmentBarycentricKHR = 5284
    ComputeDerivativeGroupQuadsKHR = 5288
    FragmentDensityEXT = 5291
    GroupNonUniformPartitionedNV = 5297
    ShaderNonUniform = 5301
    RuntimeDescriptorArray = 5302
    InputAttachmentArrayDynamicIndexing = 5303
    UniformTexelBufferArrayDynamicIndexing = 5304
    StorageTexelBufferArrayDynamicIndexing = 5305
    UniformBufferArrayNonUniformIndexing = 5306
    SampledImageArrayNonUniformIndexing = 5307
    StorageBufferArrayNonUniformIndexing = 5308
    StorageImageArrayNonUniformIndexing = 5309
    InputAttachmentArrayNonUniformIndexing = 5310
    UniformTexelBufferArrayNonUniformIndexing = 5311
    StorageTexelBufferArrayNonUniformIndexing = 5312
    RayTracingPositionFetchKHR = 5336
    RayTracingNV = 5340
    RayTracingMotionBlurNV = 5341
    VulkanMemoryModel = 5345
    VulkanMemoryModelDeviceScope = 5346
    PhysicalStorageBufferAddresses = 5347
    ComputeDerivativeGroupLinearKHR = 5350
    RayTracingProvisionalKHR = 5353
    CooperativeMatrixNV = 5357
    FragmentShaderSampleInterlockEXT = 5363
    FragmentShaderShadingRateInterlockEXT = 5372
    ShaderSMBuiltinsNV = 5373
    FragmentShaderPixelInterlockEXT = 5378
    DemoteToHelperInvocation = 5379
    DisplacementMicromapNV = 5380
    RayTracingOpacityMicromapEXT = 5381
    ShaderInvocationReorderNV = 5383
    BindlessTextureNV = 5390
    RayQueryPositionFetchKHR = 5391
    CooperativeVectorNV = 5394
    AtomicFloat16VectorNV = 5404
    RayTracingDisplacementMicromapNV = 5409
    RawAccessChainsNV = 5414
    RayTracingSpheresGeometryNV = 5418
    RayTracingLinearSweptSpheresGeometryNV = 5419
    CooperativeMatrixReductionsNV = 5430
    CooperativeMatrixConversionsNV = 5431
    CooperativeMatrixPerElementOperationsNV = 5432
    CooperativeMatrixTensorAddressingNV = 5433
    CooperativeMatrixBlockLoadsNV = 5434
    CooperativeVectorTrainingNV = 5435
    RayTracingClusterAccelerationStructureNV = 5437
    TensorAddressingNV = 5439
    SubgroupShuffleINTEL = 5568
    SubgroupBufferBlockIOINTEL = 5569
    SubgroupImageBlockIOINTEL = 5570
    SubgroupImageMediaBlockIOINTEL = 5579
    RoundToInfinityINTEL = 5582
    FloatingPointModeINTEL = 5583
    IntegerFunctions2INTEL = 5584
    FunctionPointersINTEL = 5603
    IndirectReferencesINTEL = 5604
    AsmINTEL = 5606
    AtomicFloat32MinMaxEXT = 5612
    AtomicFloat64MinMaxEXT = 5613
    AtomicFloat16MinMaxEXT = 5616
    VectorComputeINTEL = 5617
    VectorAnyINTEL = 5619
    ExpectAssumeKHR = 5629
    SubgroupAvcMotionEstimationINTEL = 5696
    SubgroupAvcMotionEstimationIntraINTEL = 5697
    SubgroupAvcMotionEstimationChromaINTEL = 5698
    VariableLengthArrayINTEL = 5817
    FunctionFloatControlINTEL = 5821
    FPGAMemoryAttributesINTEL = 5824
    FPFastMathModeINTEL = 5837
    ArbitraryPrecisionIntegersINTEL = 5844
    ArbitraryPrecisionFloatingPointINTEL = 5845
    UnstructuredLoopControlsINTEL = 5886
    FPGALoopControlsINTEL = 5888
    KernelAttributesINTEL = 5892
    FPGAKernelAttributesINTEL = 5897
    FPGAMemoryAccessesINTEL = 5898
    FPGAClusterAttributesINTEL = 5904
    LoopFuseINTEL = 5906
    FPGADSPControlINTEL = 5908
    MemoryAccessAliasingINTEL = 5910
    FPGAInvocationPipeliningAttributesINTEL = 5916
    FPGABufferLocationINTEL = 5920
    ArbitraryPrecisionFixedPointINTEL = 5922
    USMStorageClassesINTEL = 5935
    RuntimeAlignedAttributeINTEL = 5939
    IOPipesINTEL = 5943
    BlockingPipesINTEL = 5945
    FPGARegINTEL = 5948
    DotProductInputAll = 6016
    DotProductInput4x8Bit = 6017
    DotProductInput4x8BitPacked = 6018
    DotProduct = 6019
    RayCullMaskKHR = 6020
    CooperativeMatrixKHR = 6022
    ReplicatedCompositesEXT = 6024
    BitInstructions = 6025
    GroupNonUniformRotateKHR = 6026
    FloatControls2 = 6029
    AtomicFloat32AddEXT = 6033
    AtomicFloat64AddEXT = 6034
    LongCompositesINTEL = 6089
    OptNoneEXT = 6094
    AtomicFloat16AddEXT = 6095
    DebugInfoModuleINTEL = 6114
    BFloat16ConversionINTEL = 6115
    SplitBarrierINTEL = 6141
    ArithmeticFenceEXT = 6144
    FPGAClusterAttributesV2INTEL = 6150
    FPGAKernelAttributesv2INTEL = 6161
    TaskSequenceINTEL = 6162
    FPMaxErrorINTEL = 6169
    FPGALatencyControlINTEL = 6171
    FPGAArgumentInterfacesINTEL = 6174
    GlobalVariableHostAccessINTEL = 6187
    GlobalVariableFPGADecorationsINTEL = 6189
    SubgroupBufferPrefetchINTEL = 6220
    Subgroup2DBlockIOINTEL = 6228
    Subgroup2DBlockTransformINTEL = 6229
    Subgroup2DBlockTransposeINTEL = 6230
    SubgroupMatrixMultiplyAccumulateINTEL = 6236
    TernaryBitwiseFunctionINTEL = 6241
    SpecConditionalINTEL = 6245
    FunctionVariantsINTEL = 6246
    GroupUniformArithmeticKHR = 6400
    TensorFloat32RoundingINTEL = 6425
    MaskedGatherScatterINTEL = 6427
    CacheControlsINTEL = 6441
    RegisterLimitsINTEL = 6460
    BindlessImagesINTEL = 6528


class RayQueryIntersection(IntEnum):
    RayQueryCandidateIntersectionKHR = 0
    RayQueryCommittedIntersectionKHR = 1


class RayQueryCommittedIntersectionType(IntEnum):
    RayQueryCommittedIntersectionNoneKHR = 0
    RayQueryCommittedIntersectionTriangleKHR = 1
    RayQueryCommittedIntersectionGeneratedKHR = 2


class RayQueryCandidateIntersectionType(IntEnum):
    RayQueryCandidateIntersectionTriangleKHR = 0
    RayQueryCandidateIntersectionAABBKHR = 1


class PackedVectorFormat(IntEnum):
    PackedVectorFormat4x8Bit = 0


class CooperativeMatrixOperands(IntFlag):
    NoneKHR = 0x0000
    MatrixASignedComponentsKHR = 0x0001
    MatrixBSignedComponentsKHR = 0x0002
    MatrixCSignedComponentsKHR = 0x0004
    MatrixResultSignedComponentsKHR = 0x0008
    SaturatingAccumulationKHR = 0x0010


class CooperativeMatrixLayout(IntEnum):
    RowMajorKHR = 0
    ColumnMajorKHR = 1
    RowBlockedInterleavedARM = 4202
    ColumnBlockedInterleavedARM = 4203


class CooperativeMatrixUse(IntEnum):
    MatrixAKHR = 0
    MatrixBKHR = 1
    MatrixAccumulatorKHR = 2


class CooperativeMatrixReduce(IntFlag):
    Row = 0x0001
    Column = 0x0002
    _2x2 = 0x0004


class TensorClampMode(IntEnum):
    Undefined = 0
    Constant = 1
    ClampToEdge = 2
    Repeat = 3
    RepeatMirrored = 4


class TensorAddressingOperands(IntFlag):
    TensorView = 0x0001
    DecodeFunc = 0x0002


class InitializationModeQualifier(IntEnum):
    InitOnDeviceReprogramINTEL = 0
    InitOnDeviceResetINTEL = 1


class LoadCacheControl(IntEnum):
    UncachedINTEL = 0
    CachedINTEL = 1
    StreamingINTEL = 2
    InvalidateAfterReadINTEL = 3
    ConstCachedINTEL = 4


class StoreCacheControl(IntEnum):
    UncachedINTEL = 0
    WriteThroughINTEL = 1
    WriteBackINTEL = 2
    StreamingINTEL = 3


class NamedMaximumNumberOfRegisters(IntEnum):
    AutoINTEL = 0


class MatrixMultiplyAccumulateOperands(IntFlag):
    MatrixASignedComponentsINTEL = 0x1
    MatrixBSignedComponentsINTEL = 0x2
    MatrixCBFloat16INTEL = 0x4
    MatrixResultBFloat16INTEL = 0x8
    MatrixAPackedInt8INTEL = 0x10
    MatrixBPackedInt8INTEL = 0x20
    MatrixAPackedInt4INTEL = 0x40
    MatrixBPackedInt4INTEL = 0x80
    MatrixATF32INTEL = 0x100
    MatrixBTF32INTEL = 0x200
    MatrixAPackedFloat16INTEL = 0x400
    MatrixBPackedFloat16INTEL = 0x800
    MatrixAPackedBFloat16INTEL = 0x1000
    MatrixBPackedBFloat16INTEL = 0x2000


class FPEncoding(IntEnum):
    BFloat16KHR = 0
    Float8E4M3EXT = 4214
    Float8E5M2EXT = 4215


class CooperativeVectorMatrixLayout(IntEnum):
    RowMajorNV = 0
    ColumnMajorNV = 1
    InferencingOptimalNV = 2
    TrainingOptimalNV = 3


class ComponentType(IntEnum):
    Float16NV = 0
    Float32NV = 1
    Float64NV = 2
    SignedInt8NV = 3
    SignedInt16NV = 4
    SignedInt32NV = 5
    SignedInt64NV = 6
    UnsignedInt8NV = 7
    UnsignedInt16NV = 8
    UnsignedInt32NV = 9
    UnsignedInt64NV = 10
    SignedInt8PackedNV = 1000491000
    UnsignedInt8PackedNV = 1000491001
    FloatE4M3NV = 1000491002
    FloatE5M2NV = 1000491003


class TensorOperands(IntFlag):
    NoneARM = 0x0000
    NontemporalARM = 0x0001
    OutOfBoundsValueARM = 0x0002
    MakeElementAvailableARM = 0x0004
    MakeElementVisibleARM = 0x0008
    NonPrivateElementARM = 0x0010


class Op(IntEnum):
    Nop = 0
    Undef = 1
    SourceContinued = 2
    Source = 3
    SourceExtension = 4
    Name = 5
    MemberName = 6
    String = 7
    Line = 8
    Extension = 10
    ExtInstImport = 11
    ExtInst = 12
    MemoryModel = 14
    EntryPoint = 15
    ExecutionMode = 16
    Capability = 17
    TypeVoid = 19
    TypeBool = 20
    TypeInt = 21
    TypeFloat = 22
    TypeVector = 23
    TypeMatrix = 24
    TypeImage = 25
    TypeSampler = 26
    TypeSampledImage = 27
    TypeArray = 28
    TypeRuntimeArray = 29
    TypeStruct = 30
    TypeOpaque = 31
    TypePointer = 32
    TypeFunction = 33
    TypeEvent = 34
    TypeDeviceEvent = 35
    TypeReserveId = 36
    TypeQueue = 37
    TypePipe = 38
    TypeForwardPointer = 39
    ConstantTrue = 41
    ConstantFalse = 42
    Constant = 43
    ConstantComposite = 44
    ConstantSampler = 45
    ConstantNull = 46
    SpecConstantTrue = 48
    SpecConstantFalse = 49
    SpecConstant = 50
    SpecConstantComposite = 51
    SpecConstantOp = 52
    Function = 54
    FunctionParameter = 55
    FunctionEnd = 56
    FunctionCall = 57
    Variable = 59
    ImageTexelPointer = 60
    Load = 61
    Store = 62
    CopyMemory = 63
    CopyMemorySized = 64
    AccessChain = 65
    InBoundsAccessChain = 66
    PtrAccessChain = 67
    ArrayLength = 68
    GenericPtrMemSemantics = 69
    InBoundsPtrAccessChain = 70
    Decorate = 71
    MemberDecorate = 72
    DecorationGroup = 73
    GroupDecorate = 74
    GroupMemberDecorate = 75
    VectorExtractDynamic = 77
    VectorInsertDynamic = 78
    VectorShuffle = 79
    CompositeConstruct = 80
    CompositeExtract = 81
    CompositeInsert = 82
    CopyObject = 83
    Transpose = 84
    SampledImage = 86
    ImageSampleImplicitLod = 87
    ImageSampleExplicitLod = 88
    ImageSampleDrefImplicitLod = 89
    ImageSampleDrefExplicitLod = 90
    ImageSampleProjImplicitLod = 91
    ImageSampleProjExplicitLod = 92
    ImageSampleProjDrefImplicitLod = 93
    ImageSampleProjDrefExplicitLod = 94
    ImageFetch = 95
    ImageGather = 96
    ImageDrefGather = 97
    ImageRead = 98
    ImageWrite = 99
    Image = 100
    ImageQueryFormat = 101
    ImageQueryOrder = 102
    ImageQuerySizeLod = 103
    ImageQuerySize = 104
    ImageQueryLod = 105
    ImageQueryLevels = 106
    ImageQuerySamples = 107
    ConvertFToU = 109
    ConvertFToS = 110
    ConvertSToF = 111
    ConvertUToF = 112
    UConvert = 113
    SConvert = 114
    FConvert = 115
    QuantizeToF16 = 116
    ConvertPtrToU = 117
    SatConvertSToU = 118
    SatConvertUToS = 119
    ConvertUToPtr = 120
    PtrCastToGeneric = 121
    GenericCastToPtr = 122
    GenericCastToPtrExplicit = 123
    Bitcast = 124
    SNegate = 126
    FNegate = 127
    IAdd = 128
    FAdd = 129
    ISub = 130
    FSub = 131
    IMul = 132
    FMul = 133
    UDiv = 134
    SDiv = 135
    FDiv = 136
    UMod = 137
    SRem = 138
    SMod = 139
    FRem = 140
    FMod = 141
    VectorTimesScalar = 142
    MatrixTimesScalar = 143
    VectorTimesMatrix = 144
    MatrixTimesVector = 145
    MatrixTimesMatrix = 146
    OuterProduct = 147
    Dot = 148
    IAddCarry = 149
    ISubBorrow = 150
    UMulExtended = 151
    SMulExtended = 152
    Any = 154
    All = 155
    IsNan = 156
    IsInf = 157
    IsFinite = 158
    IsNormal = 159
    SignBitSet = 160
    LessOrGreater = 161
    Ordered = 162
    Unordered = 163
    LogicalEqual = 164
    LogicalNotEqual = 165
    LogicalOr = 166
    LogicalAnd = 167
    LogicalNot = 168
    Select = 169
    IEqual = 170
    INotEqual = 171
    UGreaterThan = 172
    SGreaterThan = 173
    UGreaterThanEqual = 174
    SGreaterThanEqual = 175
    ULessThan = 176
    SLessThan = 177
    ULessThanEqual = 178
    SLessThanEqual = 179
    FOrdEqual = 180
    FUnordEqual = 181
    FOrdNotEqual = 182
    FUnordNotEqual = 183
    FOrdLessThan = 184
    FUnordLessThan = 185
    FOrdGreaterThan = 186
    FUnordGreaterThan = 187
    FOrdLessThanEqual = 188
    FUnordLessThanEqual = 189
    FOrdGreaterThanEqual = 190
    FUnordGreaterThanEqual = 191
    ShiftRightLogical = 194
    ShiftRightArithmetic = 195
    ShiftLeftLogical = 196
    BitwiseOr = 197
    BitwiseXor = 198
    BitwiseAnd = 199
    Not = 200
    BitFieldInsert = 201
    BitFieldSExtract = 202
    BitFieldUExtract = 203
    BitReverse = 204
    BitCount = 205
    DPdx = 207
    DPdy = 208
    Fwidth = 209
    DPdxFine = 210
    DPdyFine = 211
    FwidthFine = 212
    DPdxCoarse = 213
    DPdyCoarse = 214
    FwidthCoarse = 215
    EmitVertex = 218
    EndPrimitive = 219
    EmitStreamVertex = 220
    EndStreamPrimitive = 221
    ControlBarrier = 224
    MemoryBarrier = 225
    AtomicLoad = 227
    AtomicStore = 228
    AtomicExchange = 229
    AtomicCompareExchange = 230
    AtomicCompareExchangeWeak = 231
    AtomicIIncrement = 232
    AtomicIDecrement = 233
    AtomicIAdd = 234
    AtomicISub = 235
    AtomicSMin = 236
    AtomicUMin = 237
    AtomicSMax = 238
    AtomicUMax = 239
    AtomicAnd = 240
    AtomicOr = 241
    AtomicXor = 242
    Phi = 245
    LoopMerge = 246
    SelectionMerge = 247
    Label = 248
    Branch = 249
    BranchConditional = 250
    Switch = 251
    Kill = 252
    Return = 253
    ReturnValue = 254
    Unreachable = 255
    LifetimeStart = 256
    LifetimeStop = 257
    GroupAsyncCopy = 259
    GroupWaitEvents = 260
    GroupAll = 261
    GroupAny = 262
    GroupBroadcast = 263
    GroupIAdd = 264
    GroupFAdd = 265
    GroupFMin = 266
    GroupUMin = 267
    GroupSMin = 268
    GroupFMax = 269
    GroupUMax = 270
    GroupSMax = 271
    ReadPipe = 274
    WritePipe = 275
    ReservedReadPipe = 276
    ReservedWritePipe = 277
    ReserveReadPipePackets = 278
    ReserveWritePipePackets = 279
    CommitReadPipe = 280
    CommitWritePipe = 281
    IsValidReserveId = 282
    GetNumPipePackets = 283
    GetMaxPipePackets = 284
    GroupReserveReadPipePackets = 285
    GroupReserveWritePipePackets = 286
    GroupCommitReadPipe = 287
    GroupCommitWritePipe = 288
    EnqueueMarker = 291
    EnqueueKernel = 292
    GetKernelNDrangeSubGroupCount = 293
    GetKernelNDrangeMaxSubGroupSize = 294
    GetKernelWorkGroupSize = 295
    GetKernelPreferredWorkGroupSizeMultiple = 296
    RetainEvent = 297
    ReleaseEvent = 298
    CreateUserEvent = 299
    IsValidEvent = 300
    SetUserEventStatus = 301
    CaptureEventProfilingInfo = 302
    GetDefaultQueue = 303
    BuildNDRange = 304
    ImageSparseSampleImplicitLod = 305
    ImageSparseSampleExplicitLod = 306
    ImageSparseSampleDrefImplicitLod = 307
    ImageSparseSampleDrefExplicitLod = 308
    ImageSparseSampleProjImplicitLod = 309
    ImageSparseSampleProjExplicitLod = 310
    ImageSparseSampleProjDrefImplicitLod = 311
    ImageSparseSampleProjDrefExplicitLod = 312
    ImageSparseFetch = 313
    ImageSparseGather = 314
    ImageSparseDrefGather = 315
    ImageSparseTexelsResident = 316
    NoLine = 317
    AtomicFlagTestAndSet = 318
    AtomicFlagClear = 319
    ImageSparseRead = 320
    SizeOf = 321
    TypePipeStorage = 322
    ConstantPipeStorage = 323
    CreatePipeFromPipeStorage = 324
    GetKernelLocalSizeForSubgroupCount = 325
    GetKernelMaxNumSubgroups = 326
    TypeNamedBarrier = 327
    NamedBarrierInitialize = 328
    MemoryNamedBarrier = 329
    ModuleProcessed = 330
    ExecutionModeId = 331
    DecorateId = 332
    GroupNonUniformElect = 333
    GroupNonUniformAll = 334
    GroupNonUniformAny = 335
    GroupNonUniformAllEqual = 336
    GroupNonUniformBroadcast = 337
    GroupNonUniformBroadcastFirst = 338
    GroupNonUniformBallot = 339
    GroupNonUniformInverseBallot = 340
    GroupNonUniformBallotBitExtract = 341
    GroupNonUniformBallotBitCount = 342
    GroupNonUniformBallotFindLSB = 343
    GroupNonUniformBallotFindMSB = 344
    GroupNonUniformShuffle = 345
    GroupNonUniformShuffleXor = 346
    GroupNonUniformShuffleUp = 347
    GroupNonUniformShuffleDown = 348
    GroupNonUniformIAdd = 349
    GroupNonUniformFAdd = 350
    GroupNonUniformIMul = 351
    GroupNonUniformFMul = 352
    GroupNonUniformSMin = 353
    GroupNonUniformUMin = 354
    GroupNonUniformFMin = 355
    GroupNonUniformSMax = 356
    GroupNonUniformUMax = 357
    GroupNonUniformFMax = 358
    GroupNonUniformBitwiseAnd = 359
    GroupNonUniformBitwiseOr = 360
    GroupNonUniformBitwiseXor = 361
    GroupNonUniformLogicalAnd = 362
    GroupNonUniformLogicalOr = 363
    GroupNonUniformLogicalXor = 364
    GroupNonUniformQuadBroadcast = 365
    GroupNonUniformQuadSwap = 366
    CopyLogical = 400
    PtrEqual = 401
    PtrNotEqual = 402
    PtrDiff = 403
    ColorAttachmentReadEXT = 4160
    DepthAttachmentReadEXT = 4161
    StencilAttachmentReadEXT = 4162
    TypeTensorARM = 4163
    TensorReadARM = 4164
    TensorWriteARM = 4165
    TensorQuerySizeARM = 4166
    GraphConstantARM = 4181
    GraphEntryPointARM = 4182
    GraphARM = 4183
    GraphInputARM = 4184
    GraphSetOutputARM = 4185
    GraphEndARM = 4186
    TypeGraphARM = 4190
    TerminateInvocation = 4416
    TypeUntypedPointerKHR = 4417
    UntypedVariableKHR = 4418
    UntypedAccessChainKHR = 4419
    UntypedInBoundsAccessChainKHR = 4420
    SubgroupBallotKHR = 4421
    SubgroupFirstInvocationKHR = 4422
    UntypedPtrAccessChainKHR = 4423
    UntypedInBoundsPtrAccessChainKHR = 4424
    UntypedArrayLengthKHR = 4425
    UntypedPrefetchKHR = 4426
    SubgroupAllKHR = 4428
    SubgroupAnyKHR = 4429
    SubgroupAllEqualKHR = 4430
    GroupNonUniformRotateKHR = 4431
    SubgroupReadInvocationKHR = 4432
    ExtInstWithForwardRefsKHR = 4433
    UntypedGroupAsyncCopyKHR = 4434
    TraceRayKHR = 4445
    ExecuteCallableKHR = 4446
    ConvertUToAccelerationStructureKHR = 4447
    IgnoreIntersectionKHR = 4448
    TerminateRayKHR = 4449
    SDot = 4450
    UDot = 4451
    SUDot = 4452
    SDotAccSat = 4453
    UDotAccSat = 4454
    SUDotAccSat = 4455
    TypeCooperativeMatrixKHR = 4456
    CooperativeMatrixLoadKHR = 4457
    CooperativeMatrixStoreKHR = 4458
    CooperativeMatrixMulAddKHR = 4459
    CooperativeMatrixLengthKHR = 4460
    ConstantCompositeReplicateEXT = 4461
    SpecConstantCompositeReplicateEXT = 4462
    CompositeConstructReplicateEXT = 4463
    TypeRayQueryKHR = 4472
    RayQueryInitializeKHR = 4473
    RayQueryTerminateKHR = 4474
    RayQueryGenerateIntersectionKHR = 4475
    RayQueryConfirmIntersectionKHR = 4476
    RayQueryProceedKHR = 4477
    RayQueryGetIntersectionTypeKHR = 4479
    ImageSampleWeightedQCOM = 4480
    ImageBoxFilterQCOM = 4481
    ImageBlockMatchSSDQCOM = 4482
    ImageBlockMatchSADQCOM = 4483
    BitCastArrayQCOM = 4497
    ImageBlockMatchWindowSSDQCOM = 4500
    ImageBlockMatchWindowSADQCOM = 4501
    ImageBlockMatchGatherSSDQCOM = 4502
    ImageBlockMatchGatherSADQCOM = 4503
    CompositeConstructCoopMatQCOM = 4540
    CompositeExtractCoopMatQCOM = 4541
    ExtractSubArrayQCOM = 4542
    GroupIAddNonUniformAMD = 5000
    GroupFAddNonUniformAMD = 5001
    GroupFMinNonUniformAMD = 5002
    GroupUMinNonUniformAMD = 5003
    GroupSMinNonUniformAMD = 5004
    GroupFMaxNonUniformAMD = 5005
    GroupUMaxNonUniformAMD = 5006
    GroupSMaxNonUniformAMD = 5007
    FragmentMaskFetchAMD = 5011
    FragmentFetchAMD = 5012
    ReadClockKHR = 5056
    AllocateNodePayloadsAMDX = 5074
    EnqueueNodePayloadsAMDX = 5075
    TypeNodePayloadArrayAMDX = 5076
    FinishWritingNodePayloadAMDX = 5078
    NodePayloadArrayLengthAMDX = 5090
    IsNodePayloadValidAMDX = 5101
    ConstantStringAMDX = 5103
    SpecConstantStringAMDX = 5104
    GroupNonUniformQuadAllKHR = 5110
    GroupNonUniformQuadAnyKHR = 5111
    HitObjectRecordHitMotionNV = 5249
    HitObjectRecordHitWithIndexMotionNV = 5250
    HitObjectRecordMissMotionNV = 5251
    HitObjectGetWorldToObjectNV = 5252
    HitObjectGetObjectToWorldNV = 5253
    HitObjectGetObjectRayDirectionNV = 5254
    HitObjectGetObjectRayOriginNV = 5255
    HitObjectTraceRayMotionNV = 5256
    HitObjectGetShaderRecordBufferHandleNV = 5257
    HitObjectGetShaderBindingTableRecordIndexNV = 5258
    HitObjectRecordEmptyNV = 5259
    HitObjectTraceRayNV = 5260
    HitObjectRecordHitNV = 5261
    HitObjectRecordHitWithIndexNV = 5262
    HitObjectRecordMissNV = 5263
    HitObjectExecuteShaderNV = 5264
    HitObjectGetCurrentTimeNV = 5265
    HitObjectGetAttributesNV = 5266
    HitObjectGetHitKindNV = 5267
    HitObjectGetPrimitiveIndexNV = 5268
    HitObjectGetGeometryIndexNV = 5269
    HitObjectGetInstanceIdNV = 5270
    HitObjectGetInstanceCustomIndexNV = 5271
    HitObjectGetWorldRayDirectionNV = 5272
    HitObjectGetWorldRayOriginNV = 5273
    HitObjectGetRayTMaxNV = 5274
    HitObjectGetRayTMinNV = 5275
    HitObjectIsEmptyNV = 5276
    HitObjectIsHitNV = 5277
    HitObjectIsMissNV = 5278
    ReorderThreadWithHitObjectNV = 5279
    ReorderThreadWithHintNV = 5280
    TypeHitObjectNV = 5281
    ImageSampleFootprintNV = 5283
    TypeCooperativeVectorNV = 5288
    CooperativeVectorMatrixMulNV = 5289
    CooperativeVectorOuterProductAccumulateNV = 5290
    CooperativeVectorReduceSumAccumulateNV = 5291
    CooperativeVectorMatrixMulAddNV = 5292
    CooperativeMatrixConvertNV = 5293
    EmitMeshTasksEXT = 5294
    SetMeshOutputsEXT = 5295
    GroupNonUniformPartitionNV = 5296
    WritePackedPrimitiveIndices4x8NV = 5299
    FetchMicroTriangleVertexPositionNV = 5300
    FetchMicroTriangleVertexBarycentricNV = 5301
    CooperativeVectorLoadNV = 5302
    CooperativeVectorStoreNV = 5303
    ReportIntersectionKHR = 5334
    IgnoreIntersectionNV = 5335
    TerminateRayNV = 5336
    TraceNV = 5337
    TraceMotionNV = 5338
    TraceRayMotionNV = 5339
    RayQueryGetIntersectionTriangleVertexPositionsKHR = 5340
    TypeAccelerationStructureKHR = 5341
    ExecuteCallableNV = 5344
    RayQueryGetClusterIdNV = 5345
    HitObjectGetClusterIdNV = 5346
    TypeCooperativeMatrixNV = 5358
    CooperativeMatrixLoadNV = 5359
    CooperativeMatrixStoreNV = 5360
    CooperativeMatrixMulAddNV = 5361
    CooperativeMatrixLengthNV = 5362
    BeginInvocationInterlockEXT = 5364
    EndInvocationInterlockEXT = 5365
    CooperativeMatrixReduceNV = 5366
    CooperativeMatrixLoadTensorNV = 5367
    CooperativeMatrixStoreTensorNV = 5368
    CooperativeMatrixPerElementOpNV = 5369
    TypeTensorLayoutNV = 5370
    TypeTensorViewNV = 5371
    CreateTensorLayoutNV = 5372
    TensorLayoutSetDimensionNV = 5373
    TensorLayoutSetStrideNV = 5374
    TensorLayoutSliceNV = 5375
    TensorLayoutSetClampValueNV = 5376
    CreateTensorViewNV = 5377
    TensorViewSetDimensionNV = 5378
    TensorViewSetStrideNV = 5379
    DemoteToHelperInvocation = 5380
    IsHelperInvocationEXT = 5381
    TensorViewSetClipNV = 5382
    TensorLayoutSetBlockSizeNV = 5384
    CooperativeMatrixTransposeNV = 5390
    ConvertUToImageNV = 5391
    ConvertUToSamplerNV = 5392
    ConvertImageToUNV = 5393
    ConvertSamplerToUNV = 5394
    ConvertUToSampledImageNV = 5395
    ConvertSampledImageToUNV = 5396
    SamplerImageAddressingModeNV = 5397
    RawAccessChainNV = 5398
    RayQueryGetIntersectionSpherePositionNV = 5427
    RayQueryGetIntersectionSphereRadiusNV = 5428
    RayQueryGetIntersectionLSSPositionsNV = 5429
    RayQueryGetIntersectionLSSRadiiNV = 5430
    RayQueryGetIntersectionLSSHitValueNV = 5431
    HitObjectGetSpherePositionNV = 5432
    HitObjectGetSphereRadiusNV = 5433
    HitObjectGetLSSPositionsNV = 5434
    HitObjectGetLSSRadiiNV = 5435
    HitObjectIsSphereHitNV = 5436
    HitObjectIsLSSHitNV = 5437
    RayQueryIsSphereHitNV = 5438
    RayQueryIsLSSHitNV = 5439
    SubgroupShuffleINTEL = 5571
    SubgroupShuffleDownINTEL = 5572
    SubgroupShuffleUpINTEL = 5573
    SubgroupShuffleXorINTEL = 5574
    SubgroupBlockReadINTEL = 5575
    SubgroupBlockWriteINTEL = 5576
    SubgroupImageBlockReadINTEL = 5577
    SubgroupImageBlockWriteINTEL = 5578
    SubgroupImageMediaBlockReadINTEL = 5580
    SubgroupImageMediaBlockWriteINTEL = 5581
    UCountLeadingZerosINTEL = 5585
    UCountTrailingZerosINTEL = 5586
    AbsISubINTEL = 5587
    AbsUSubINTEL = 5588
    IAddSatINTEL = 5589
    UAddSatINTEL = 5590
    IAverageINTEL = 5591
    UAverageINTEL = 5592
    IAverageRoundedINTEL = 5593
    UAverageRoundedINTEL = 5594
    ISubSatINTEL = 5595
    USubSatINTEL = 5596
    IMul32x16INTEL = 5597
    UMul32x16INTEL = 5598
    ConstantFunctionPointerINTEL = 5600
    FunctionPointerCallINTEL = 5601
    AsmTargetINTEL = 5609
    AsmINTEL = 5610
    AsmCallINTEL = 5611
    AtomicFMinEXT = 5614
    AtomicFMaxEXT = 5615
    AssumeTrueKHR = 5630
    ExpectKHR = 5631
    DecorateString = 5632
    MemberDecorateString = 5633
    VmeImageINTEL = 5699
    TypeVmeImageINTEL = 5700
    TypeAvcImePayloadINTEL = 5701
    TypeAvcRefPayloadINTEL = 5702
    TypeAvcSicPayloadINTEL = 5703
    TypeAvcMcePayloadINTEL = 5704
    TypeAvcMceResultINTEL = 5705
    TypeAvcImeResultINTEL = 5706
    TypeAvcImeResultSingleReferenceStreamoutINTEL = 5707
    TypeAvcImeResultDualReferenceStreamoutINTEL = 5708
    TypeAvcImeSingleReferenceStreaminINTEL = 5709
    TypeAvcImeDualReferenceStreaminINTEL = 5710
    TypeAvcRefResultINTEL = 5711
    TypeAvcSicResultINTEL = 5712
    SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL = 5713
    SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL = 5714
    SubgroupAvcMceGetDefaultInterShapePenaltyINTEL = 5715
    SubgroupAvcMceSetInterShapePenaltyINTEL = 5716
    SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL = 5717
    SubgroupAvcMceSetInterDirectionPenaltyINTEL = 5718
    SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL = 5719
    SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL = 5720
    SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL = 5721
    SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL = 5722
    SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL = 5723
    SubgroupAvcMceSetMotionVectorCostFunctionINTEL = 5724
    SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL = 5725
    SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL = 5726
    SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL = 5727
    SubgroupAvcMceSetAcOnlyHaarINTEL = 5728
    SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL = 5729
    SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL = 5730
    SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL = 5731
    SubgroupAvcMceConvertToImePayloadINTEL = 5732
    SubgroupAvcMceConvertToImeResultINTEL = 5733
    SubgroupAvcMceConvertToRefPayloadINTEL = 5734
    SubgroupAvcMceConvertToRefResultINTEL = 5735
    SubgroupAvcMceConvertToSicPayloadINTEL = 5736
    SubgroupAvcMceConvertToSicResultINTEL = 5737
    SubgroupAvcMceGetMotionVectorsINTEL = 5738
    SubgroupAvcMceGetInterDistortionsINTEL = 5739
    SubgroupAvcMceGetBestInterDistortionsINTEL = 5740
    SubgroupAvcMceGetInterMajorShapeINTEL = 5741
    SubgroupAvcMceGetInterMinorShapeINTEL = 5742
    SubgroupAvcMceGetInterDirectionsINTEL = 5743
    SubgroupAvcMceGetInterMotionVectorCountINTEL = 5744
    SubgroupAvcMceGetInterReferenceIdsINTEL = 5745
    SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL = 5746
    SubgroupAvcImeInitializeINTEL = 5747
    SubgroupAvcImeSetSingleReferenceINTEL = 5748
    SubgroupAvcImeSetDualReferenceINTEL = 5749
    SubgroupAvcImeRefWindowSizeINTEL = 5750
    SubgroupAvcImeAdjustRefOffsetINTEL = 5751
    SubgroupAvcImeConvertToMcePayloadINTEL = 5752
    SubgroupAvcImeSetMaxMotionVectorCountINTEL = 5753
    SubgroupAvcImeSetUnidirectionalMixDisableINTEL = 5754
    SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL = 5755
    SubgroupAvcImeSetWeightedSadINTEL = 5756
    SubgroupAvcImeEvaluateWithSingleReferenceINTEL = 5757
    SubgroupAvcImeEvaluateWithDualReferenceINTEL = 5758
    SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL = 5759
    SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL = 5760
    SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL = 5761
    SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL = 5762
    SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL = 5763
    SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL = 5764
    SubgroupAvcImeConvertToMceResultINTEL = 5765
    SubgroupAvcImeGetSingleReferenceStreaminINTEL = 5766
    SubgroupAvcImeGetDualReferenceStreaminINTEL = 5767
    SubgroupAvcImeStripSingleReferenceStreamoutINTEL = 5768
    SubgroupAvcImeStripDualReferenceStreamoutINTEL = 5769
    SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL = 5770
    SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL = 5771
    SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL = 5772
    SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL = 5773
    SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL = 5774
    SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL = 5775
    SubgroupAvcImeGetBorderReachedINTEL = 5776
    SubgroupAvcImeGetTruncatedSearchIndicationINTEL = 5777
    SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL = 5778
    SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL = 5779
    SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL = 5780
    SubgroupAvcFmeInitializeINTEL = 5781
    SubgroupAvcBmeInitializeINTEL = 5782
    SubgroupAvcRefConvertToMcePayloadINTEL = 5783
    SubgroupAvcRefSetBidirectionalMixDisableINTEL = 5784
    SubgroupAvcRefSetBilinearFilterEnableINTEL = 5785
    SubgroupAvcRefEvaluateWithSingleReferenceINTEL = 5786
    SubgroupAvcRefEvaluateWithDualReferenceINTEL = 5787
    SubgroupAvcRefEvaluateWithMultiReferenceINTEL = 5788
    SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL = 5789
    SubgroupAvcRefConvertToMceResultINTEL = 5790
    SubgroupAvcSicInitializeINTEL = 5791
    SubgroupAvcSicConfigureSkcINTEL = 5792
    SubgroupAvcSicConfigureIpeLumaINTEL = 5793
    SubgroupAvcSicConfigureIpeLumaChromaINTEL = 5794
    SubgroupAvcSicGetMotionVectorMaskINTEL = 5795
    SubgroupAvcSicConvertToMcePayloadINTEL = 5796
    SubgroupAvcSicSetIntraLumaShapePenaltyINTEL = 5797
    SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL = 5798
    SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL = 5799
    SubgroupAvcSicSetBilinearFilterEnableINTEL = 5800
    SubgroupAvcSicSetSkcForwardTransformEnableINTEL = 5801
    SubgroupAvcSicSetBlockBasedRawSkipSadINTEL = 5802
    SubgroupAvcSicEvaluateIpeINTEL = 5803
    SubgroupAvcSicEvaluateWithSingleReferenceINTEL = 5804
    SubgroupAvcSicEvaluateWithDualReferenceINTEL = 5805
    SubgroupAvcSicEvaluateWithMultiReferenceINTEL = 5806
    SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL = 5807
    SubgroupAvcSicConvertToMceResultINTEL = 5808
    SubgroupAvcSicGetIpeLumaShapeINTEL = 5809
    SubgroupAvcSicGetBestIpeLumaDistortionINTEL = 5810
    SubgroupAvcSicGetBestIpeChromaDistortionINTEL = 5811
    SubgroupAvcSicGetPackedIpeLumaModesINTEL = 5812
    SubgroupAvcSicGetIpeChromaModeINTEL = 5813
    SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL = 5814
    SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL = 5815
    SubgroupAvcSicGetInterRawSadsINTEL = 5816
    VariableLengthArrayINTEL = 5818
    SaveMemoryINTEL = 5819
    RestoreMemoryINTEL = 5820
    ArbitraryFloatSinCosPiINTEL = 5840
    ArbitraryFloatCastINTEL = 5841
    ArbitraryFloatCastFromIntINTEL = 5842
    ArbitraryFloatCastToIntINTEL = 5843
    ArbitraryFloatAddINTEL = 5846
    ArbitraryFloatSubINTEL = 5847
    ArbitraryFloatMulINTEL = 5848
    ArbitraryFloatDivINTEL = 5849
    ArbitraryFloatGTINTEL = 5850
    ArbitraryFloatGEINTEL = 5851
    ArbitraryFloatLTINTEL = 5852
    ArbitraryFloatLEINTEL = 5853
    ArbitraryFloatEQINTEL = 5854
    ArbitraryFloatRecipINTEL = 5855
    ArbitraryFloatRSqrtINTEL = 5856
    ArbitraryFloatCbrtINTEL = 5857
    ArbitraryFloatHypotINTEL = 5858
    ArbitraryFloatSqrtINTEL = 5859
    ArbitraryFloatLogINTEL = 5860
    ArbitraryFloatLog2INTEL = 5861
    ArbitraryFloatLog10INTEL = 5862
    ArbitraryFloatLog1pINTEL = 5863
    ArbitraryFloatExpINTEL = 5864
    ArbitraryFloatExp2INTEL = 5865
    ArbitraryFloatExp10INTEL = 5866
    ArbitraryFloatExpm1INTEL = 5867
    ArbitraryFloatSinINTEL = 5868
    ArbitraryFloatCosINTEL = 5869
    ArbitraryFloatSinCosINTEL = 5870
    ArbitraryFloatSinPiINTEL = 5871
    ArbitraryFloatCosPiINTEL = 5872
    ArbitraryFloatASinINTEL = 5873
    ArbitraryFloatASinPiINTEL = 5874
    ArbitraryFloatACosINTEL = 5875
    ArbitraryFloatACosPiINTEL = 5876
    ArbitraryFloatATanINTEL = 5877
    ArbitraryFloatATanPiINTEL = 5878
    ArbitraryFloatATan2INTEL = 5879
    ArbitraryFloatPowINTEL = 5880
    ArbitraryFloatPowRINTEL = 5881
    ArbitraryFloatPowNINTEL = 5882
    LoopControlINTEL = 5887
    AliasDomainDeclINTEL = 5911
    AliasScopeDeclINTEL = 5912
    AliasScopeListDeclINTEL = 5913
    FixedSqrtINTEL = 5923
    FixedRecipINTEL = 5924
    FixedRsqrtINTEL = 5925
    FixedSinINTEL = 5926
    FixedCosINTEL = 5927
    FixedSinCosINTEL = 5928
    FixedSinPiINTEL = 5929
    FixedCosPiINTEL = 5930
    FixedSinCosPiINTEL = 5931
    FixedLogINTEL = 5932
    FixedExpINTEL = 5933
    PtrCastToCrossWorkgroupINTEL = 5934
    CrossWorkgroupCastToPtrINTEL = 5938
    ReadPipeBlockingINTEL = 5946
    WritePipeBlockingINTEL = 5947
    FPGARegINTEL = 5949
    RayQueryGetRayTMinKHR = 6016
    RayQueryGetRayFlagsKHR = 6017
    RayQueryGetIntersectionTKHR = 6018
    RayQueryGetIntersectionInstanceCustomIndexKHR = 6019
    RayQueryGetIntersectionInstanceIdKHR = 6020
    RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR = 6021
    RayQueryGetIntersectionGeometryIndexKHR = 6022
    RayQueryGetIntersectionPrimitiveIndexKHR = 6023
    RayQueryGetIntersectionBarycentricsKHR = 6024
    RayQueryGetIntersectionFrontFaceKHR = 6025
    RayQueryGetIntersectionCandidateAABBOpaqueKHR = 6026
    RayQueryGetIntersectionObjectRayDirectionKHR = 6027
    RayQueryGetIntersectionObjectRayOriginKHR = 6028
    RayQueryGetWorldRayDirectionKHR = 6029
    RayQueryGetWorldRayOriginKHR = 6030
    RayQueryGetIntersectionObjectToWorldKHR = 6031
    RayQueryGetIntersectionWorldToObjectKHR = 6032
    AtomicFAddEXT = 6035
    TypeBufferSurfaceINTEL = 6086
    TypeStructContinuedINTEL = 6090
    ConstantCompositeContinuedINTEL = 6091
    SpecConstantCompositeContinuedINTEL = 6092
    CompositeConstructContinuedINTEL = 6096
    ConvertFToBF16INTEL = 6116
    ConvertBF16ToFINTEL = 6117
    ControlBarrierArriveINTEL = 6142
    ControlBarrierWaitINTEL = 6143
    ArithmeticFenceEXT = 6145
    TaskSequenceCreateINTEL = 6163
    TaskSequenceAsyncINTEL = 6164
    TaskSequenceGetINTEL = 6165
    TaskSequenceReleaseINTEL = 6166
    TypeTaskSequenceINTEL = 6199
    SubgroupBlockPrefetchINTEL = 6221
    Subgroup2DBlockLoadINTEL = 6231
    Subgroup2DBlockLoadTransformINTEL = 6232
    Subgroup2DBlockLoadTransposeINTEL = 6233
    Subgroup2DBlockPrefetchINTEL = 6234
    Subgroup2DBlockStoreINTEL = 6235
    SubgroupMatrixMultiplyAccumulateINTEL = 6237
    BitwiseFunctionINTEL = 6242
    ConditionalExtensionINTEL = 6248
    ConditionalEntryPointINTEL = 6249
    ConditionalCapabilityINTEL = 6250
    SpecConstantTargetINTEL = 6251
    SpecConstantArchitectureINTEL = 6252
    SpecConstantCapabilitiesINTEL = 6253
    ConditionalCopyObjectINTEL = 6254
    GroupIMulKHR = 6401
    GroupFMulKHR = 6402
    GroupBitwiseAndKHR = 6403
    GroupBitwiseOrKHR = 6404
    GroupBitwiseXorKHR = 6405
    GroupLogicalAndKHR = 6406
    GroupLogicalOrKHR = 6407
    GroupLogicalXorKHR = 6408
    RoundFToTF32INTEL = 6426
    MaskedGatherINTEL = 6428
    MaskedScatterINTEL = 6429
    ConvertHandleToImageINTEL = 6529
    ConvertHandleToSamplerINTEL = 6530
    ConvertHandleToSampledImageINTEL = 6531


ANNOTATION_OPS = [
    Op.Decorate,
    Op.MemberDecorate,
    Op.DecorationGroup,
    Op.GroupDecorate,
    Op.GroupMemberDecorate,
    Op.DecorateId,
    Op.DecorateString,
    Op.MemberDecorateString,
]

CONSTANT_OPS = [
    Op.ConstantTrue,
    Op.ConstantFalse,
    Op.Constant,
    Op.ConstantComposite,
    Op.ConstantSampler,
    Op.ConstantNull,
    Op.SpecConstantTrue,
    Op.SpecConstantFalse,
    Op.SpecConstant,
    Op.SpecConstantComposite,
    Op.SpecConstantOp,
    Op.ConstantCompositeReplicateEXT,
    Op.SpecConstantCompositeReplicateEXT,
    Op.ConstantCompositeContinuedINTEL,
    Op.SpecConstantCompositeContinuedINTEL,
    Op.SpecConstantTargetINTEL,
    Op.SpecConstantArchitectureINTEL,
    Op.SpecConstantCapabilitiesINTEL,
]

TYPEDECL_OPS = [
    Op.TypeVoid,
    Op.TypeBool,
    Op.TypeInt,
    Op.TypeFloat,
    Op.TypeVector,
    Op.TypeMatrix,
    Op.TypeImage,
    Op.TypeSampler,
    Op.TypeSampledImage,
    Op.TypeArray,
    Op.TypeRuntimeArray,
    Op.TypeStruct,
    Op.TypeOpaque,
    Op.TypePointer,
    Op.TypeFunction,
    Op.TypeEvent,
    Op.TypeDeviceEvent,
    Op.TypeReserveId,
    Op.TypeQueue,
    Op.TypePipe,
    Op.TypeForwardPointer,
    Op.TypePipeStorage,
    Op.TypeNamedBarrier,
    Op.TypeTensorARM,
    Op.TypeGraphARM,
    Op.TypeUntypedPointerKHR,
    Op.TypeCooperativeMatrixKHR,
    Op.TypeRayQueryKHR,
    Op.TypeHitObjectNV,
    Op.TypeCooperativeVectorNV,
    Op.TypeAccelerationStructureKHR,
    Op.TypeCooperativeMatrixNV,
    Op.TypeTensorLayoutNV,
    Op.TypeTensorViewNV,
    Op.TypeBufferSurfaceINTEL,
    Op.TypeStructContinuedINTEL,
    Op.TypeTaskSequenceINTEL,
]

CONSTANT_OPS = [
    Op.ConstantTrue,
    Op.ConstantFalse,
    Op.Constant,
    Op.ConstantComposite,
    Op.ConstantSampler,
    Op.ConstantNull,
    Op.SpecConstantTrue,
    Op.SpecConstantFalse,
    Op.SpecConstant,
    Op.SpecConstantComposite,
    Op.SpecConstantOp,
    Op.ConstantCompositeReplicateEXT,
    Op.SpecConstantCompositeReplicateEXT,
    Op.ConstantCompositeContinuedINTEL,
    Op.SpecConstantCompositeContinuedINTEL,
    Op.SpecConstantTargetINTEL,
    Op.SpecConstantArchitectureINTEL,
    Op.SpecConstantCapabilitiesINTEL,
]


def OpNop() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Nop,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpUndef(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Undef,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpSourceContinued(
    x: str,  # Continued Source
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SourceContinued,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpSource(
    x: SourceLanguage,
    y: int,  # Version
    z: Optional[SpirvInstruction] = None,  # File
    a: Optional[str] = None,  # Source
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Source,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpSourceExtension(
    x: str,  # Extension
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SourceExtension,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpName(
    x: SpirvInstruction,  # Target
    y: str,  # Name
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Name,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpMemberName(
    x: SpirvInstruction,  # Type
    y: int,  # Member
    z: str,  # Name
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MemberName,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpString(
    x: str,  # String
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.String,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpLine(
    x: SpirvInstruction,  # File
    y: int,  # Line
    z: int,  # Column
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Line,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpExtension(
    x: str,  # Name
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Extension,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpExtInstImport(
    x: str,  # Name
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ExtInstImport,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpExtInst(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Set
    y: int,  # Instruction
    *z: SpirvInstruction,  # Operand 1, Operand 2, ...
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ExtInst,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpMemoryModel(
    x: AddressingModel,
    y: MemoryModel,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MemoryModel,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpEntryPoint(
    x: ExecutionModel,
    y: SpirvInstruction,  # Entry Point
    z: str,  # Name
    *a: SpirvInstruction,  # Interface
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.EntryPoint,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpExecutionMode(
    x: SpirvInstruction,  # Entry Point
    y: ExecutionMode,  # Mode
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ExecutionMode,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpCapability(
    x: Capability,  # Capability
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Capability,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpTypeVoid() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeVoid,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeBool() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeBool,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeInt(
    x: int,  # Width
    y: int,  # Signedness
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeInt,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeFloat(
    x: int,  # Width
    y: Optional[FPEncoding] = None,  # Floating Point Encoding
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeFloat,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeVector(
    x: SpirvInstruction,  # Component Type
    y: int,  # Component Count
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeVector,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeMatrix(
    x: SpirvInstruction,  # Column Type
    y: int,  # Column Count
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeMatrix,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeImage(
    x: SpirvInstruction,  # Sampled Type
    y: Dim,
    z: int,  # Depth
    a: int,  # Arrayed
    b: int,  # MS
    c: int,  # Sampled
    d: ImageFormat,
    e: Optional[AccessQualifier] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeImage,
        args=(x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeSampler() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeSampler,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeSampledImage(
    x: SpirvInstruction,  # Image Type
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeSampledImage,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeArray(
    x: SpirvInstruction,  # Element Type
    y: SpirvInstruction,  # Length
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeArray,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeRuntimeArray(
    x: SpirvInstruction,  # Element Type
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeRuntimeArray,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeStruct(
    *x: SpirvInstruction,  # Member 0 type, member 1 type, ...
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeStruct,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeOpaque(
    x: str,  # The name of the opaque type.
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeOpaque,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpTypePointer(
    x: StorageClass,
    y: SpirvInstruction,  # Type
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypePointer,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeFunction(
    x: SpirvInstruction,  # Return Type
    *y: SpirvInstruction,  # Parameter 0 Type, Parameter 1 Type, ...
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeFunction,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeEvent() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeEvent,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeDeviceEvent() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeDeviceEvent,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeReserveId() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeReserveId,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeQueue() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeQueue,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypePipe(
    x: AccessQualifier,  # Qualifier
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypePipe,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeForwardPointer(
    x: SpirvInstruction,  # Pointer Type
    y: StorageClass,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeForwardPointer,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpConstantTrue(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConstantTrue,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpConstantFalse(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConstantFalse,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpConstant(
    rtype: SpirvInstruction,
    x: float,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Constant,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConstantComposite(
    rtype: SpirvInstruction,
    *x: SpirvInstruction,  # Constituents
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConstantComposite,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConstantSampler(
    rtype: SpirvInstruction,
    x: SamplerAddressingMode,
    y: int,  # Param
    z: SamplerFilterMode,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConstantSampler,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpConstantNull(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConstantNull,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpSpecConstantTrue(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SpecConstantTrue,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpSpecConstantFalse(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SpecConstantFalse,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpSpecConstant(
    rtype: SpirvInstruction,
    x: float,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SpecConstant,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSpecConstantComposite(
    rtype: SpirvInstruction,
    *x: SpirvInstruction,  # Constituents
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SpecConstantComposite,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSpecConstantOp(
    rtype: SpirvInstruction,
    x: int,  # Opcode
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SpecConstantOp,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpFunction(
    rtype: SpirvInstruction,
    x: FunctionControl,
    y: SpirvInstruction,  # Function Type
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Function,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFunctionParameter(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FunctionParameter,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpFunctionEnd() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FunctionEnd,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpFunctionCall(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Function
    *y: SpirvInstruction,  # Argument 0, Argument 1, ...
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FunctionCall,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpVariable(
    rtype: SpirvInstruction,
    x: StorageClass,
    y: Optional[SpirvInstruction] = None,  # Initializer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Variable,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpImageTexelPointer(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # Sample
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageTexelPointer,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpLoad(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: Optional[MemoryAccess] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Load,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpStore(
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Object
    z: Optional[MemoryAccess] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Store,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpCopyMemory(
    x: SpirvInstruction,  # Target
    y: SpirvInstruction,  # Source
    z: Optional[MemoryAccess] = None,
    a: Optional[MemoryAccess] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CopyMemory,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpCopyMemorySized(
    x: SpirvInstruction,  # Target
    y: SpirvInstruction,  # Source
    z: SpirvInstruction,  # Size
    a: Optional[MemoryAccess] = None,
    b: Optional[MemoryAccess] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CopyMemorySized,
        args=(x, y, z, a, b),
        hasresult=False,
        hasrtype=False,
    )


def OpAccessChain(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    *y: SpirvInstruction,  # Indexes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AccessChain,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpInBoundsAccessChain(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    *y: SpirvInstruction,  # Indexes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.InBoundsAccessChain,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpPtrAccessChain(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    y: SpirvInstruction,  # Element
    *z: SpirvInstruction,  # Indexes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.PtrAccessChain,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpArrayLength(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Structure
    y: int,  # Array member
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArrayLength,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGenericPtrMemSemantics(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GenericPtrMemSemantics,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpInBoundsPtrAccessChain(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    y: SpirvInstruction,  # Element
    *z: SpirvInstruction,  # Indexes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.InBoundsPtrAccessChain,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpDecorate(
    x: SpirvInstruction,  # Target
    y: Decoration,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Decorate,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpMemberDecorate(
    x: SpirvInstruction,  # Structure Type
    y: int,  # Member
    z: Decoration,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MemberDecorate,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpDecorationGroup() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DecorationGroup,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpGroupDecorate(
    x: SpirvInstruction,  # Decoration Group
    *y: SpirvInstruction,  # Targets
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupDecorate,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpGroupMemberDecorate(
    x: SpirvInstruction,  # Decoration Group
    *y: tuple[SpirvInstruction, int],  # Targets
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupMemberDecorate,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpVectorExtractDynamic(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector
    y: SpirvInstruction,  # Index
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.VectorExtractDynamic,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpVectorInsertDynamic(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector
    y: SpirvInstruction,  # Component
    z: SpirvInstruction,  # Index
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.VectorInsertDynamic,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpVectorShuffle(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    *z: int,  # Components
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.VectorShuffle,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpCompositeConstruct(
    rtype: SpirvInstruction,
    *x: SpirvInstruction,  # Constituents
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CompositeConstruct,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpCompositeExtract(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Composite
    *y: int,  # Indexes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CompositeExtract,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpCompositeInsert(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Object
    y: SpirvInstruction,  # Composite
    *z: int,  # Indexes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CompositeInsert,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpCopyObject(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CopyObject,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpTranspose(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Matrix
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Transpose,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSampledImage(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Sampler
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SampledImage,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSampleImplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSampleImplicitLod,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSampleExplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: ImageOperands,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSampleExplicitLod,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSampleDrefImplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # D~ref~
    a: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSampleDrefImplicitLod,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSampleDrefExplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # D~ref~
    a: ImageOperands,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSampleDrefExplicitLod,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSampleProjImplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSampleProjImplicitLod,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSampleProjExplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: ImageOperands,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSampleProjExplicitLod,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSampleProjDrefImplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # D~ref~
    a: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSampleProjDrefImplicitLod,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSampleProjDrefExplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # D~ref~
    a: ImageOperands,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSampleProjDrefExplicitLod,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageFetch(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
    z: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageFetch,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageGather(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # Component
    a: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageGather,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageDrefGather(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # D~ref~
    a: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageDrefGather,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageRead(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
    z: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageRead,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageWrite(
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # Texel
    a: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageWrite,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpImage(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Image,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpImageQueryFormat(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageQueryFormat,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpImageQueryOrder(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageQueryOrder,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpImageQuerySizeLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Level of Detail
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageQuerySizeLod,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpImageQuerySize(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageQuerySize,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpImageQueryLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageQueryLod,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpImageQueryLevels(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageQueryLevels,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpImageQuerySamples(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageQuerySamples,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertFToU(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Float Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertFToU,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertFToS(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Float Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertFToS,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertSToF(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Signed Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertSToF,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertUToF(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Unsigned Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertUToF,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpUConvert(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Unsigned Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UConvert,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSConvert(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Signed Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SConvert,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpFConvert(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Float Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FConvert,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpQuantizeToF16(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.QuantizeToF16,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertPtrToU(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertPtrToU,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSatConvertSToU(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Signed Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SatConvertSToU,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSatConvertUToS(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Unsigned Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SatConvertUToS,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertUToPtr(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Integer Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertUToPtr,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpPtrCastToGeneric(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.PtrCastToGeneric,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpGenericCastToPtr(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GenericCastToPtr,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpGenericCastToPtrExplicit(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: StorageClass,  # Storage
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GenericCastToPtrExplicit,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpBitcast(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Bitcast,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSNegate(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SNegate,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpFNegate(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FNegate,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpIAdd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IAdd,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFAdd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FAdd,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpISub(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ISub,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFSub(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FSub,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpIMul(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IMul,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFMul(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FMul,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUDiv(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UDiv,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSDiv(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SDiv,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFDiv(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FDiv,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUMod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UMod,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSRem(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SRem,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSMod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SMod,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFRem(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FRem,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFMod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FMod,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpVectorTimesScalar(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector
    y: SpirvInstruction,  # Scalar
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.VectorTimesScalar,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpMatrixTimesScalar(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Matrix
    y: SpirvInstruction,  # Scalar
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MatrixTimesScalar,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpVectorTimesMatrix(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector
    y: SpirvInstruction,  # Matrix
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.VectorTimesMatrix,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpMatrixTimesVector(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Matrix
    y: SpirvInstruction,  # Vector
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MatrixTimesVector,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpMatrixTimesMatrix(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # LeftMatrix
    y: SpirvInstruction,  # RightMatrix
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MatrixTimesMatrix,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpOuterProduct(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.OuterProduct,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpDot(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Dot,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpIAddCarry(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IAddCarry,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpISubBorrow(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ISubBorrow,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUMulExtended(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UMulExtended,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSMulExtended(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SMulExtended,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpAny(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Any,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpAll(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.All,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpIsNan(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # x
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IsNan,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpIsInf(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # x
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IsInf,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpIsFinite(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # x
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IsFinite,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpIsNormal(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # x
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IsNormal,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSignBitSet(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # x
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SignBitSet,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpLessOrGreater(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # x
    y: SpirvInstruction,  # y
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.LessOrGreater,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpOrdered(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # x
    y: SpirvInstruction,  # y
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Ordered,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUnordered(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # x
    y: SpirvInstruction,  # y
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Unordered,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpLogicalEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.LogicalEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpLogicalNotEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.LogicalNotEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpLogicalOr(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.LogicalOr,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpLogicalAnd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.LogicalAnd,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpLogicalNot(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.LogicalNot,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSelect(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Condition
    y: SpirvInstruction,  # Object 1
    z: SpirvInstruction,  # Object 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Select,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpIEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpINotEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.INotEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUGreaterThan(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UGreaterThan,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSGreaterThan(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SGreaterThan,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUGreaterThanEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UGreaterThanEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSGreaterThanEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SGreaterThanEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpULessThan(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ULessThan,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSLessThan(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SLessThan,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpULessThanEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ULessThanEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSLessThanEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SLessThanEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFOrdEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FOrdEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFUnordEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FUnordEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFOrdNotEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FOrdNotEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFUnordNotEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FUnordNotEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFOrdLessThan(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FOrdLessThan,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFUnordLessThan(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FUnordLessThan,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFOrdGreaterThan(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FOrdGreaterThan,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFUnordGreaterThan(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FUnordGreaterThan,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFOrdLessThanEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FOrdLessThanEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFUnordLessThanEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FUnordLessThanEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFOrdGreaterThanEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FOrdGreaterThanEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFUnordGreaterThanEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FUnordGreaterThanEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpShiftRightLogical(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    y: SpirvInstruction,  # Shift
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ShiftRightLogical,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpShiftRightArithmetic(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    y: SpirvInstruction,  # Shift
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ShiftRightArithmetic,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpShiftLeftLogical(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    y: SpirvInstruction,  # Shift
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ShiftLeftLogical,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpBitwiseOr(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BitwiseOr,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpBitwiseXor(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BitwiseXor,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpBitwiseAnd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BitwiseAnd,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpNot(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Not,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpBitFieldInsert(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    y: SpirvInstruction,  # Insert
    z: SpirvInstruction,  # Offset
    a: SpirvInstruction,  # Count
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BitFieldInsert,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpBitFieldSExtract(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    y: SpirvInstruction,  # Offset
    z: SpirvInstruction,  # Count
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BitFieldSExtract,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpBitFieldUExtract(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    y: SpirvInstruction,  # Offset
    z: SpirvInstruction,  # Count
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BitFieldUExtract,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpBitReverse(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BitReverse,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpBitCount(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BitCount,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpDPdx(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # P
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DPdx,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpDPdy(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # P
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DPdy,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpFwidth(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # P
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Fwidth,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpDPdxFine(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # P
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DPdxFine,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpDPdyFine(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # P
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DPdyFine,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpFwidthFine(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # P
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FwidthFine,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpDPdxCoarse(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # P
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DPdxCoarse,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpDPdyCoarse(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # P
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DPdyCoarse,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpFwidthCoarse(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # P
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FwidthCoarse,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpEmitVertex() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.EmitVertex,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpEndPrimitive() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.EndPrimitive,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpEmitStreamVertex(
    x: SpirvInstruction,  # Stream
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.EmitStreamVertex,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpEndStreamPrimitive(
    x: SpirvInstruction,  # Stream
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.EndStreamPrimitive,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpControlBarrier(
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ControlBarrier,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpMemoryBarrier(
    x: SpirvInstruction,  # Memory
    y: SpirvInstruction,  # Semantics
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MemoryBarrier,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpAtomicLoad(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicLoad,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicStore(
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicStore,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpAtomicExchange(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicExchange,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicCompareExchange(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Equal
    a: SpirvInstruction,  # Unequal
    b: SpirvInstruction,  # Value
    c: SpirvInstruction,  # Comparator
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicCompareExchange,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicCompareExchangeWeak(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Equal
    a: SpirvInstruction,  # Unequal
    b: SpirvInstruction,  # Value
    c: SpirvInstruction,  # Comparator
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicCompareExchangeWeak,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicIIncrement(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicIIncrement,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicIDecrement(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicIDecrement,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicIAdd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicIAdd,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicISub(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicISub,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicSMin(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicSMin,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicUMin(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicUMin,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicSMax(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicSMax,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicUMax(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicUMax,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicAnd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicAnd,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicOr(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicOr,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicXor(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicXor,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpPhi(
    rtype: SpirvInstruction,
    *x: tuple[SpirvInstruction, SpirvInstruction],  # Variable, Parent, ...
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Phi,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpLoopMerge(
    x: SpirvInstruction,  # Merge Block
    y: SpirvInstruction,  # Continue Target
    z: LoopControl,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.LoopMerge,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpSelectionMerge(
    x: SpirvInstruction,  # Merge Block
    y: SelectionControl,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SelectionMerge,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpLabel() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Label,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpBranch(
    x: SpirvInstruction,  # Target Label
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Branch,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpBranchConditional(
    x: SpirvInstruction,  # Condition
    y: SpirvInstruction,  # True Label
    z: SpirvInstruction,  # False Label
    *a: int,  # Branch weights
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BranchConditional,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpSwitch(
    x: SpirvInstruction,  # Selector
    y: SpirvInstruction,  # Default
    *z: tuple[int, SpirvInstruction],  # Target
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Switch,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpKill() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Kill,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpReturn() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Return,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpReturnValue(
    x: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReturnValue,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpUnreachable() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Unreachable,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpLifetimeStart(
    x: SpirvInstruction,  # Pointer
    y: int,  # Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.LifetimeStart,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpLifetimeStop(
    x: SpirvInstruction,  # Pointer
    y: int,  # Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.LifetimeStop,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpGroupAsyncCopy(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Destination
    z: SpirvInstruction,  # Source
    a: SpirvInstruction,  # Num Elements
    b: SpirvInstruction,  # Stride
    c: SpirvInstruction,  # Event
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupAsyncCopy,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupWaitEvents(
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Num Events
    z: SpirvInstruction,  # Events List
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupWaitEvents,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpGroupAll(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupAll,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupAny(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupAny,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupBroadcast(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
    z: SpirvInstruction,  # LocalId
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupBroadcast,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupIAdd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupIAdd,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupFAdd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupFAdd,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupFMin(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupFMin,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupUMin(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupUMin,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupSMin(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupSMin,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupFMax(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupFMax,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupUMax(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupUMax,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupSMax(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupSMax,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpReadPipe(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pipe
    y: SpirvInstruction,  # Pointer
    z: SpirvInstruction,  # Packet Size
    a: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReadPipe,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpWritePipe(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pipe
    y: SpirvInstruction,  # Pointer
    z: SpirvInstruction,  # Packet Size
    a: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.WritePipe,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpReservedReadPipe(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pipe
    y: SpirvInstruction,  # Reserve Id
    z: SpirvInstruction,  # Index
    a: SpirvInstruction,  # Pointer
    b: SpirvInstruction,  # Packet Size
    c: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReservedReadPipe,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpReservedWritePipe(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pipe
    y: SpirvInstruction,  # Reserve Id
    z: SpirvInstruction,  # Index
    a: SpirvInstruction,  # Pointer
    b: SpirvInstruction,  # Packet Size
    c: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReservedWritePipe,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpReserveReadPipePackets(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pipe
    y: SpirvInstruction,  # Num Packets
    z: SpirvInstruction,  # Packet Size
    a: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReserveReadPipePackets,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpReserveWritePipePackets(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pipe
    y: SpirvInstruction,  # Num Packets
    z: SpirvInstruction,  # Packet Size
    a: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReserveWritePipePackets,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpCommitReadPipe(
    x: SpirvInstruction,  # Pipe
    y: SpirvInstruction,  # Reserve Id
    z: SpirvInstruction,  # Packet Size
    a: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CommitReadPipe,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpCommitWritePipe(
    x: SpirvInstruction,  # Pipe
    y: SpirvInstruction,  # Reserve Id
    z: SpirvInstruction,  # Packet Size
    a: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CommitWritePipe,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpIsValidReserveId(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Reserve Id
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IsValidReserveId,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpGetNumPipePackets(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pipe
    y: SpirvInstruction,  # Packet Size
    z: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GetNumPipePackets,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGetMaxPipePackets(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pipe
    y: SpirvInstruction,  # Packet Size
    z: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GetMaxPipePackets,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupReserveReadPipePackets(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Pipe
    z: SpirvInstruction,  # Num Packets
    a: SpirvInstruction,  # Packet Size
    b: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupReserveReadPipePackets,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupReserveWritePipePackets(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Pipe
    z: SpirvInstruction,  # Num Packets
    a: SpirvInstruction,  # Packet Size
    b: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupReserveWritePipePackets,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupCommitReadPipe(
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Pipe
    z: SpirvInstruction,  # Reserve Id
    a: SpirvInstruction,  # Packet Size
    b: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupCommitReadPipe,
        args=(x, y, z, a, b),
        hasresult=False,
        hasrtype=False,
    )


def OpGroupCommitWritePipe(
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Pipe
    z: SpirvInstruction,  # Reserve Id
    a: SpirvInstruction,  # Packet Size
    b: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupCommitWritePipe,
        args=(x, y, z, a, b),
        hasresult=False,
        hasrtype=False,
    )


def OpEnqueueMarker(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Queue
    y: SpirvInstruction,  # Num Events
    z: SpirvInstruction,  # Wait Events
    a: SpirvInstruction,  # Ret Event
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.EnqueueMarker,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpEnqueueKernel(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Queue
    y: SpirvInstruction,  # Flags
    z: SpirvInstruction,  # ND Range
    a: SpirvInstruction,  # Num Events
    b: SpirvInstruction,  # Wait Events
    c: SpirvInstruction,  # Ret Event
    d: SpirvInstruction,  # Invoke
    e: SpirvInstruction,  # Param
    f: SpirvInstruction,  # Param Size
    g: SpirvInstruction,  # Param Align
    *h: SpirvInstruction,  # Local Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.EnqueueKernel,
        args=(rtype, x, y, z, a, b, c, d, e, f, g, h),
        hasresult=True,
        hasrtype=True,
    )


def OpGetKernelNDrangeSubGroupCount(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # ND Range
    y: SpirvInstruction,  # Invoke
    z: SpirvInstruction,  # Param
    a: SpirvInstruction,  # Param Size
    b: SpirvInstruction,  # Param Align
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GetKernelNDrangeSubGroupCount,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpGetKernelNDrangeMaxSubGroupSize(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # ND Range
    y: SpirvInstruction,  # Invoke
    z: SpirvInstruction,  # Param
    a: SpirvInstruction,  # Param Size
    b: SpirvInstruction,  # Param Align
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GetKernelNDrangeMaxSubGroupSize,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpGetKernelWorkGroupSize(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Invoke
    y: SpirvInstruction,  # Param
    z: SpirvInstruction,  # Param Size
    a: SpirvInstruction,  # Param Align
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GetKernelWorkGroupSize,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGetKernelPreferredWorkGroupSizeMultiple(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Invoke
    y: SpirvInstruction,  # Param
    z: SpirvInstruction,  # Param Size
    a: SpirvInstruction,  # Param Align
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GetKernelPreferredWorkGroupSizeMultiple,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpRetainEvent(
    x: SpirvInstruction,  # Event
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RetainEvent,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpReleaseEvent(
    x: SpirvInstruction,  # Event
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReleaseEvent,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpCreateUserEvent(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CreateUserEvent,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpIsValidEvent(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Event
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IsValidEvent,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSetUserEventStatus(
    x: SpirvInstruction,  # Event
    y: SpirvInstruction,  # Status
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SetUserEventStatus,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpCaptureEventProfilingInfo(
    x: SpirvInstruction,  # Event
    y: SpirvInstruction,  # Profiling Info
    z: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CaptureEventProfilingInfo,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpGetDefaultQueue(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GetDefaultQueue,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpBuildNDRange(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # GlobalWorkSize
    y: SpirvInstruction,  # LocalWorkSize
    z: SpirvInstruction,  # GlobalWorkOffset
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BuildNDRange,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseSampleImplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseSampleImplicitLod,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseSampleExplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: ImageOperands,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseSampleExplicitLod,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseSampleDrefImplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # D~ref~
    a: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseSampleDrefImplicitLod,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseSampleDrefExplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # D~ref~
    a: ImageOperands,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseSampleDrefExplicitLod,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseSampleProjImplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseSampleProjImplicitLod,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseSampleProjExplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: ImageOperands,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseSampleProjExplicitLod,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseSampleProjDrefImplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # D~ref~
    a: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseSampleProjDrefImplicitLod,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseSampleProjDrefExplicitLod(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # D~ref~
    a: ImageOperands,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseSampleProjDrefExplicitLod,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseFetch(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
    z: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseFetch,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseGather(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # Component
    a: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseGather,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseDrefGather(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # D~ref~
    a: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseDrefGather,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSparseTexelsResident(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Resident Code
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseTexelsResident,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpNoLine() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.NoLine,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpAtomicFlagTestAndSet(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicFlagTestAndSet,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicFlagClear(
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicFlagClear,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpImageSparseRead(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
    z: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSparseRead,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSizeOf(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SizeOf,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpTypePipeStorage() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypePipeStorage,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpConstantPipeStorage(
    rtype: SpirvInstruction,
    x: int,  # Packet Size
    y: int,  # Packet Alignment
    z: int,  # Capacity
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConstantPipeStorage,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpCreatePipeFromPipeStorage(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pipe Storage
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CreatePipeFromPipeStorage,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpGetKernelLocalSizeForSubgroupCount(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Subgroup Count
    y: SpirvInstruction,  # Invoke
    z: SpirvInstruction,  # Param
    a: SpirvInstruction,  # Param Size
    b: SpirvInstruction,  # Param Align
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GetKernelLocalSizeForSubgroupCount,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpGetKernelMaxNumSubgroups(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Invoke
    y: SpirvInstruction,  # Param
    z: SpirvInstruction,  # Param Size
    a: SpirvInstruction,  # Param Align
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GetKernelMaxNumSubgroups,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpTypeNamedBarrier() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeNamedBarrier,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpNamedBarrierInitialize(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Subgroup Count
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.NamedBarrierInitialize,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpMemoryNamedBarrier(
    x: SpirvInstruction,  # Named Barrier
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MemoryNamedBarrier,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpModuleProcessed(
    x: str,  # Process
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ModuleProcessed,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpExecutionModeId(
    x: SpirvInstruction,  # Entry Point
    y: ExecutionMode,  # Mode
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ExecutionModeId,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpDecorateId(
    x: SpirvInstruction,  # Target
    y: Decoration,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DecorateId,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpGroupNonUniformElect(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformElect,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformAll(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformAll,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformAny(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformAny,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformAllEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformAllEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformBroadcast(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
    z: SpirvInstruction,  # Invocation Id
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformBroadcast,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformBroadcastFirst(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformBroadcastFirst,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformBallot(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformBallot,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformInverseBallot(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformInverseBallot,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformBallotBitExtract(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
    z: SpirvInstruction,  # Index
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformBallotBitExtract,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformBallotBitCount(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformBallotBitCount,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformBallotFindLSB(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformBallotFindLSB,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformBallotFindMSB(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformBallotFindMSB,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformShuffle(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
    z: SpirvInstruction,  # Invocation Id
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformShuffle,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformShuffleXor(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
    z: SpirvInstruction,  # Mask
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformShuffleXor,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformShuffleUp(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
    z: SpirvInstruction,  # Delta
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformShuffleUp,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformShuffleDown(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
    z: SpirvInstruction,  # Delta
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformShuffleDown,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformIAdd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformIAdd,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformFAdd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformFAdd,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformIMul(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformIMul,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformFMul(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformFMul,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformSMin(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformSMin,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformUMin(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformUMin,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformFMin(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformFMin,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformSMax(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformSMax,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformUMax(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformUMax,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformFMax(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformFMax,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformBitwiseAnd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformBitwiseAnd,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformBitwiseOr(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformBitwiseOr,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformBitwiseXor(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformBitwiseXor,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformLogicalAnd(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformLogicalAnd,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformLogicalOr(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformLogicalOr,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformLogicalXor(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # Value
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformLogicalXor,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformQuadBroadcast(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
    z: SpirvInstruction,  # Index
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformQuadBroadcast,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformQuadSwap(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
    z: SpirvInstruction,  # Direction
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformQuadSwap,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpCopyLogical(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CopyLogical,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpPtrEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.PtrEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpPtrNotEqual(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.PtrNotEqual,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpPtrDiff(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.PtrDiff,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpColorAttachmentReadEXT(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Attachment
    y: Optional[SpirvInstruction] = None,  # Sample
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ColorAttachmentReadEXT,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpDepthAttachmentReadEXT(
    rtype: SpirvInstruction,
    x: Optional[SpirvInstruction] = None,  # Sample
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DepthAttachmentReadEXT,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpStencilAttachmentReadEXT(
    rtype: SpirvInstruction,
    x: Optional[SpirvInstruction] = None,  # Sample
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.StencilAttachmentReadEXT,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpTypeTensorARM(
    x: SpirvInstruction,  # Element Type
    y: Optional[SpirvInstruction] = None,  # Rank
    z: Optional[SpirvInstruction] = None,  # Shape
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeTensorARM,
        args=(x, y, z),
        hasresult=True,
        hasrtype=False,
    )


def OpTensorReadARM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Tensor
    y: SpirvInstruction,  # Coordinates
    z: Optional[TensorOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorReadARM,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpTensorWriteARM(
    x: SpirvInstruction,  # Tensor
    y: SpirvInstruction,  # Coordinates
    z: SpirvInstruction,  # Object
    a: Optional[TensorOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorWriteARM,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpTensorQuerySizeARM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Tensor
    y: SpirvInstruction,  # Dimension
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorQuerySizeARM,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGraphConstantARM(
    rtype: SpirvInstruction,
    x: int,  # GraphConstantID
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GraphConstantARM,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpGraphEntryPointARM(
    x: SpirvInstruction,  # Graph
    y: str,  # Name
    *z: SpirvInstruction,  # Interface
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GraphEntryPointARM,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpGraphARM(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GraphARM,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpGraphInputARM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # InputIndex
    *y: SpirvInstruction,  # ElementIndex
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GraphInputARM,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGraphSetOutputARM(
    x: SpirvInstruction,  # Value
    y: SpirvInstruction,  # OutputIndex
    *z: SpirvInstruction,  # ElementIndex
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GraphSetOutputARM,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpGraphEndARM() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GraphEndARM,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpTypeGraphARM(
    x: int,  # NumInputs
    *y: SpirvInstruction,  # InOutTypes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeGraphARM,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpTerminateInvocation() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TerminateInvocation,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpTypeUntypedPointerKHR(
    x: StorageClass,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeUntypedPointerKHR,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpUntypedVariableKHR(
    rtype: SpirvInstruction,
    x: StorageClass,
    y: Optional[SpirvInstruction] = None,  # Data Type
    z: Optional[SpirvInstruction] = None,  # Initializer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UntypedVariableKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpUntypedAccessChainKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base Type
    y: SpirvInstruction,  # Base
    *z: SpirvInstruction,  # Indexes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UntypedAccessChainKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpUntypedInBoundsAccessChainKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base Type
    y: SpirvInstruction,  # Base
    *z: SpirvInstruction,  # Indexes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UntypedInBoundsAccessChainKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupBallotKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupBallotKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupFirstInvocationKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupFirstInvocationKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpUntypedPtrAccessChainKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base Type
    y: SpirvInstruction,  # Base
    z: SpirvInstruction,  # Element
    *a: SpirvInstruction,  # Indexes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UntypedPtrAccessChainKHR,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpUntypedInBoundsPtrAccessChainKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base Type
    y: SpirvInstruction,  # Base
    z: SpirvInstruction,  # Element
    *a: SpirvInstruction,  # Indexes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UntypedInBoundsPtrAccessChainKHR,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpUntypedArrayLengthKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Structure
    y: SpirvInstruction,  # Pointer
    z: int,  # Array member
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UntypedArrayLengthKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpUntypedPrefetchKHR(
    x: SpirvInstruction,  # Pointer Type
    y: SpirvInstruction,  # Num Bytes
    z: Optional[SpirvInstruction] = None,  # RW
    a: Optional[SpirvInstruction] = None,  # Locality
    b: Optional[SpirvInstruction] = None,  # Cache Type
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UntypedPrefetchKHR,
        args=(x, y, z, a, b),
        hasresult=False,
        hasrtype=False,
    )


def OpSubgroupAllKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAllKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAnyKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAnyKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAllEqualKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAllEqualKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformRotateKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Value
    z: SpirvInstruction,  # Delta
    a: Optional[SpirvInstruction] = None,  # ClusterSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformRotateKHR,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupReadInvocationKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Value
    y: SpirvInstruction,  # Index
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupReadInvocationKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpExtInstWithForwardRefsKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Set
    y: int,  # Instruction
    *z: SpirvInstruction,  # Operand 1, Operand 2, ...
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ExtInstWithForwardRefsKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpUntypedGroupAsyncCopyKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Destination
    z: SpirvInstruction,  # Source
    a: SpirvInstruction,  # Element Num Bytes
    b: SpirvInstruction,  # Num Elements
    c: SpirvInstruction,  # Stride
    d: SpirvInstruction,  # Event
    e: Optional[MemoryAccess] = None,  # Destination Memory Operands
    f: Optional[MemoryAccess] = None,  # Source Memory Operands
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UntypedGroupAsyncCopyKHR,
        args=(rtype, x, y, z, a, b, c, d, e, f),
        hasresult=True,
        hasrtype=True,
    )


def OpTraceRayKHR(
    x: SpirvInstruction,  # Accel
    y: SpirvInstruction,  # Ray Flags
    z: SpirvInstruction,  # Cull Mask
    a: SpirvInstruction,  # SBT Offset
    b: SpirvInstruction,  # SBT Stride
    c: SpirvInstruction,  # Miss Index
    d: SpirvInstruction,  # Ray Origin
    e: SpirvInstruction,  # Ray Tmin
    f: SpirvInstruction,  # Ray Direction
    g: SpirvInstruction,  # Ray Tmax
    h: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TraceRayKHR,
        args=(x, y, z, a, b, c, d, e, f, g, h),
        hasresult=False,
        hasrtype=False,
    )


def OpExecuteCallableKHR(
    x: SpirvInstruction,  # SBT Index
    y: SpirvInstruction,  # Callable Data
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ExecuteCallableKHR,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpConvertUToAccelerationStructureKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Accel
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertUToAccelerationStructureKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpIgnoreIntersectionKHR() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IgnoreIntersectionKHR,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpTerminateRayKHR() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TerminateRayKHR,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpSDot(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SDot,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSDotKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SDot,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpUDot(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UDot,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpUDotKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UDot,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSUDot(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SUDot,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSUDotKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SUDot,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSDotAccSat(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: SpirvInstruction,  # Accumulator
    a: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SDotAccSat,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSDotAccSatKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: SpirvInstruction,  # Accumulator
    a: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SDotAccSat,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpUDotAccSat(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: SpirvInstruction,  # Accumulator
    a: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UDotAccSat,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpUDotAccSatKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: SpirvInstruction,  # Accumulator
    a: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UDotAccSat,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSUDotAccSat(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: SpirvInstruction,  # Accumulator
    a: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SUDotAccSat,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSUDotAccSatKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Vector 1
    y: SpirvInstruction,  # Vector 2
    z: SpirvInstruction,  # Accumulator
    a: Optional[PackedVectorFormat] = None,  # Packed Vector Format
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SUDotAccSat,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpTypeCooperativeMatrixKHR(
    x: SpirvInstruction,  # Component Type
    y: SpirvInstruction,  # Scope
    z: SpirvInstruction,  # Rows
    a: SpirvInstruction,  # Columns
    b: SpirvInstruction,  # Use
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeCooperativeMatrixKHR,
        args=(x, y, z, a, b),
        hasresult=True,
        hasrtype=False,
    )


def OpCooperativeMatrixLoadKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # MemoryLayout
    z: Optional[SpirvInstruction] = None,  # Stride
    a: Optional[MemoryAccess] = None,  # Memory Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixLoadKHR,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeMatrixStoreKHR(
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Object
    z: SpirvInstruction,  # MemoryLayout
    a: Optional[SpirvInstruction] = None,  # Stride
    b: Optional[MemoryAccess] = None,  # Memory Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixStoreKHR,
        args=(x, y, z, a, b),
        hasresult=False,
        hasrtype=False,
    )


def OpCooperativeMatrixMulAddKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: SpirvInstruction,  # B
    z: SpirvInstruction,  # C
    a: Optional[CooperativeMatrixOperands] = None,  # Cooperative Matrix Operands
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixMulAddKHR,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeMatrixLengthKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Type
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixLengthKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConstantCompositeReplicateEXT(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConstantCompositeReplicateEXT,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSpecConstantCompositeReplicateEXT(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SpecConstantCompositeReplicateEXT,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpCompositeConstructReplicateEXT(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CompositeConstructReplicateEXT,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpTypeRayQueryKHR() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeRayQueryKHR,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpRayQueryInitializeKHR(
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Accel
    z: SpirvInstruction,  # RayFlags
    a: SpirvInstruction,  # CullMask
    b: SpirvInstruction,  # RayOrigin
    c: SpirvInstruction,  # RayTMin
    d: SpirvInstruction,  # RayDirection
    e: SpirvInstruction,  # RayTMax
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryInitializeKHR,
        args=(x, y, z, a, b, c, d, e),
        hasresult=False,
        hasrtype=False,
    )


def OpRayQueryTerminateKHR(
    x: SpirvInstruction,  # RayQuery
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryTerminateKHR,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpRayQueryGenerateIntersectionKHR(
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # HitT
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGenerateIntersectionKHR,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpRayQueryConfirmIntersectionKHR(
    x: SpirvInstruction,  # RayQuery
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryConfirmIntersectionKHR,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpRayQueryProceedKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryProceedKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionTypeKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionTypeKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpImageSampleWeightedQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Texture
    y: SpirvInstruction,  # Coordinates
    z: SpirvInstruction,  # Weights
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSampleWeightedQCOM,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageBoxFilterQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Texture
    y: SpirvInstruction,  # Coordinates
    z: SpirvInstruction,  # Box Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageBoxFilterQCOM,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpImageBlockMatchSSDQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Target
    y: SpirvInstruction,  # Target Coordinates
    z: SpirvInstruction,  # Reference
    a: SpirvInstruction,  # Reference Coordinates
    b: SpirvInstruction,  # Block Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageBlockMatchSSDQCOM,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpImageBlockMatchSADQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Target
    y: SpirvInstruction,  # Target Coordinates
    z: SpirvInstruction,  # Reference
    a: SpirvInstruction,  # Reference Coordinates
    b: SpirvInstruction,  # Block Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageBlockMatchSADQCOM,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpBitCastArrayQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Source Array
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BitCastArrayQCOM,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpImageBlockMatchWindowSSDQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Target Sampled Image
    y: SpirvInstruction,  # Target Coordinates
    z: SpirvInstruction,  # Reference Sampled Image
    a: SpirvInstruction,  # Reference Coordinates
    b: SpirvInstruction,  # Block Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageBlockMatchWindowSSDQCOM,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpImageBlockMatchWindowSADQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Target Sampled Image
    y: SpirvInstruction,  # Target Coordinates
    z: SpirvInstruction,  # Reference Sampled Image
    a: SpirvInstruction,  # Reference Coordinates
    b: SpirvInstruction,  # Block Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageBlockMatchWindowSADQCOM,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpImageBlockMatchGatherSSDQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Target Sampled Image
    y: SpirvInstruction,  # Target Coordinates
    z: SpirvInstruction,  # Reference Sampled Image
    a: SpirvInstruction,  # Reference Coordinates
    b: SpirvInstruction,  # Block Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageBlockMatchGatherSSDQCOM,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpImageBlockMatchGatherSADQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Target Sampled Image
    y: SpirvInstruction,  # Target Coordinates
    z: SpirvInstruction,  # Reference Sampled Image
    a: SpirvInstruction,  # Reference Coordinates
    b: SpirvInstruction,  # Block Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageBlockMatchGatherSADQCOM,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpCompositeConstructCoopMatQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Source Array
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CompositeConstructCoopMatQCOM,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpCompositeExtractCoopMatQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Source Cooperative Matrix
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CompositeExtractCoopMatQCOM,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpExtractSubArrayQCOM(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Source Array
    y: SpirvInstruction,  # index
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ExtractSubArrayQCOM,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupIAddNonUniformAMD(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupIAddNonUniformAMD,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupFAddNonUniformAMD(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupFAddNonUniformAMD,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupFMinNonUniformAMD(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupFMinNonUniformAMD,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupUMinNonUniformAMD(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupUMinNonUniformAMD,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupSMinNonUniformAMD(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupSMinNonUniformAMD,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupFMaxNonUniformAMD(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupFMaxNonUniformAMD,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupUMaxNonUniformAMD(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupUMaxNonUniformAMD,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupSMaxNonUniformAMD(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupSMaxNonUniformAMD,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpFragmentMaskFetchAMD(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FragmentMaskFetchAMD,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFragmentFetchAMD(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # Fragment Index
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FragmentFetchAMD,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpReadClockKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Scope
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReadClockKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformQuadAllKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformQuadAllKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupNonUniformQuadAnyKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Predicate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformQuadAnyKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectRecordHitMotionNV(
    x: SpirvInstruction,  # Hit Object
    y: SpirvInstruction,  # Acceleration Structure
    z: SpirvInstruction,  # InstanceId
    a: SpirvInstruction,  # PrimitiveId
    b: SpirvInstruction,  # GeometryIndex
    c: SpirvInstruction,  # Hit Kind
    d: SpirvInstruction,  # SBT Record Offset
    e: SpirvInstruction,  # SBT Record Stride
    f: SpirvInstruction,  # Origin
    g: SpirvInstruction,  # TMin
    h: SpirvInstruction,  # Direction
    i: SpirvInstruction,  # TMax
    j: SpirvInstruction,  # Current Time
    k: SpirvInstruction,  # HitObject Attributes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectRecordHitMotionNV,
        args=(x, y, z, a, b, c, d, e, f, g, h, i, j, k),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectRecordHitWithIndexMotionNV(
    x: SpirvInstruction,  # Hit Object
    y: SpirvInstruction,  # Acceleration Structure
    z: SpirvInstruction,  # InstanceId
    a: SpirvInstruction,  # PrimitiveId
    b: SpirvInstruction,  # GeometryIndex
    c: SpirvInstruction,  # Hit Kind
    d: SpirvInstruction,  # SBT Record Index
    e: SpirvInstruction,  # Origin
    f: SpirvInstruction,  # TMin
    g: SpirvInstruction,  # Direction
    h: SpirvInstruction,  # TMax
    i: SpirvInstruction,  # Current Time
    j: SpirvInstruction,  # HitObject Attributes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectRecordHitWithIndexMotionNV,
        args=(x, y, z, a, b, c, d, e, f, g, h, i, j),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectRecordMissMotionNV(
    x: SpirvInstruction,  # Hit Object
    y: SpirvInstruction,  # SBT Index
    z: SpirvInstruction,  # Origin
    a: SpirvInstruction,  # TMin
    b: SpirvInstruction,  # Direction
    c: SpirvInstruction,  # TMax
    d: SpirvInstruction,  # Current Time
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectRecordMissMotionNV,
        args=(x, y, z, a, b, c, d),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectGetWorldToObjectNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetWorldToObjectNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetObjectToWorldNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetObjectToWorldNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetObjectRayDirectionNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetObjectRayDirectionNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetObjectRayOriginNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetObjectRayOriginNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectTraceRayMotionNV(
    x: SpirvInstruction,  # Hit Object
    y: SpirvInstruction,  # Acceleration Structure
    z: SpirvInstruction,  # RayFlags
    a: SpirvInstruction,  # Cullmask
    b: SpirvInstruction,  # SBT Record Offset
    c: SpirvInstruction,  # SBT Record Stride
    d: SpirvInstruction,  # Miss Index
    e: SpirvInstruction,  # Origin
    f: SpirvInstruction,  # TMin
    g: SpirvInstruction,  # Direction
    h: SpirvInstruction,  # TMax
    i: SpirvInstruction,  # Time
    j: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectTraceRayMotionNV,
        args=(x, y, z, a, b, c, d, e, f, g, h, i, j),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectGetShaderRecordBufferHandleNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetShaderRecordBufferHandleNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetShaderBindingTableRecordIndexNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetShaderBindingTableRecordIndexNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectRecordEmptyNV(
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectRecordEmptyNV,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectTraceRayNV(
    x: SpirvInstruction,  # Hit Object
    y: SpirvInstruction,  # Acceleration Structure
    z: SpirvInstruction,  # RayFlags
    a: SpirvInstruction,  # Cullmask
    b: SpirvInstruction,  # SBT Record Offset
    c: SpirvInstruction,  # SBT Record Stride
    d: SpirvInstruction,  # Miss Index
    e: SpirvInstruction,  # Origin
    f: SpirvInstruction,  # TMin
    g: SpirvInstruction,  # Direction
    h: SpirvInstruction,  # TMax
    i: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectTraceRayNV,
        args=(x, y, z, a, b, c, d, e, f, g, h, i),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectRecordHitNV(
    x: SpirvInstruction,  # Hit Object
    y: SpirvInstruction,  # Acceleration Structure
    z: SpirvInstruction,  # InstanceId
    a: SpirvInstruction,  # PrimitiveId
    b: SpirvInstruction,  # GeometryIndex
    c: SpirvInstruction,  # Hit Kind
    d: SpirvInstruction,  # SBT Record Offset
    e: SpirvInstruction,  # SBT Record Stride
    f: SpirvInstruction,  # Origin
    g: SpirvInstruction,  # TMin
    h: SpirvInstruction,  # Direction
    i: SpirvInstruction,  # TMax
    j: SpirvInstruction,  # HitObject Attributes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectRecordHitNV,
        args=(x, y, z, a, b, c, d, e, f, g, h, i, j),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectRecordHitWithIndexNV(
    x: SpirvInstruction,  # Hit Object
    y: SpirvInstruction,  # Acceleration Structure
    z: SpirvInstruction,  # InstanceId
    a: SpirvInstruction,  # PrimitiveId
    b: SpirvInstruction,  # GeometryIndex
    c: SpirvInstruction,  # Hit Kind
    d: SpirvInstruction,  # SBT Record Index
    e: SpirvInstruction,  # Origin
    f: SpirvInstruction,  # TMin
    g: SpirvInstruction,  # Direction
    h: SpirvInstruction,  # TMax
    i: SpirvInstruction,  # HitObject Attributes
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectRecordHitWithIndexNV,
        args=(x, y, z, a, b, c, d, e, f, g, h, i),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectRecordMissNV(
    x: SpirvInstruction,  # Hit Object
    y: SpirvInstruction,  # SBT Index
    z: SpirvInstruction,  # Origin
    a: SpirvInstruction,  # TMin
    b: SpirvInstruction,  # Direction
    c: SpirvInstruction,  # TMax
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectRecordMissNV,
        args=(x, y, z, a, b, c),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectExecuteShaderNV(
    x: SpirvInstruction,  # Hit Object
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectExecuteShaderNV,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectGetCurrentTimeNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetCurrentTimeNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetAttributesNV(
    x: SpirvInstruction,  # Hit Object
    y: SpirvInstruction,  # Hit Object Attribute
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetAttributesNV,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpHitObjectGetHitKindNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetHitKindNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetPrimitiveIndexNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetPrimitiveIndexNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetGeometryIndexNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetGeometryIndexNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetInstanceIdNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetInstanceIdNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetInstanceCustomIndexNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetInstanceCustomIndexNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetWorldRayDirectionNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetWorldRayDirectionNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetWorldRayOriginNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetWorldRayOriginNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetRayTMaxNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetRayTMaxNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetRayTMinNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetRayTMinNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectIsEmptyNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectIsEmptyNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectIsHitNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectIsHitNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectIsMissNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectIsMissNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpReorderThreadWithHitObjectNV(
    x: SpirvInstruction,  # Hit Object
    y: Optional[SpirvInstruction] = None,  # Hint
    z: Optional[SpirvInstruction] = None,  # Bits
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReorderThreadWithHitObjectNV,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpReorderThreadWithHintNV(
    x: SpirvInstruction,  # Hint
    y: SpirvInstruction,  # Bits
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReorderThreadWithHintNV,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpTypeHitObjectNV() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeHitObjectNV,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpImageSampleFootprintNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sampled Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # Granularity
    a: SpirvInstruction,  # Coarse
    b: Optional[ImageOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ImageSampleFootprintNV,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpTypeCooperativeVectorNV(
    x: SpirvInstruction,  # Component Type
    y: SpirvInstruction,  # Component Count
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeCooperativeVectorNV,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpCooperativeVectorMatrixMulNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: SpirvInstruction,  # InputInterpretation
    z: SpirvInstruction,  # Matrix
    a: SpirvInstruction,  # MatrixOffset
    b: SpirvInstruction,  # MatrixInterpretation
    c: SpirvInstruction,  # M
    d: SpirvInstruction,  # K
    e: SpirvInstruction,  # MemoryLayout
    f: SpirvInstruction,  # Transpose
    g: Optional[SpirvInstruction] = None,  # MatrixStride
    h: Optional[CooperativeMatrixOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeVectorMatrixMulNV,
        args=(rtype, x, y, z, a, b, c, d, e, f, g, h),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeVectorOuterProductAccumulateNV(
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Offset
    z: SpirvInstruction,  # A
    a: SpirvInstruction,  # B
    b: SpirvInstruction,  # MemoryLayout
    c: SpirvInstruction,  # MatrixInterpretation
    d: Optional[SpirvInstruction] = None,  # MatrixStride
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeVectorOuterProductAccumulateNV,
        args=(x, y, z, a, b, c, d),
        hasresult=False,
        hasrtype=False,
    )


def OpCooperativeVectorReduceSumAccumulateNV(
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Offset
    z: SpirvInstruction,  # V
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeVectorReduceSumAccumulateNV,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpCooperativeVectorMatrixMulAddNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: SpirvInstruction,  # InputInterpretation
    z: SpirvInstruction,  # Matrix
    a: SpirvInstruction,  # MatrixOffset
    b: SpirvInstruction,  # MatrixInterpretation
    c: SpirvInstruction,  # Bias
    d: SpirvInstruction,  # BiasOffset
    e: SpirvInstruction,  # BiasInterpretation
    f: SpirvInstruction,  # M
    g: SpirvInstruction,  # K
    h: SpirvInstruction,  # MemoryLayout
    i: SpirvInstruction,  # Transpose
    j: Optional[SpirvInstruction] = None,  # MatrixStride
    k: Optional[CooperativeMatrixOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeVectorMatrixMulAddNV,
        args=(rtype, x, y, z, a, b, c, d, e, f, g, h, i, j, k),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeMatrixConvertNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Matrix
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixConvertNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpEmitMeshTasksEXT(
    x: SpirvInstruction,  # Group Count X
    y: SpirvInstruction,  # Group Count Y
    z: SpirvInstruction,  # Group Count Z
    a: Optional[SpirvInstruction] = None,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.EmitMeshTasksEXT,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpSetMeshOutputsEXT(
    x: SpirvInstruction,  # Vertex Count
    y: SpirvInstruction,  # Primitive Count
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SetMeshOutputsEXT,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpGroupNonUniformPartitionNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupNonUniformPartitionNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpWritePackedPrimitiveIndices4x8NV(
    x: SpirvInstruction,  # Index Offset
    y: SpirvInstruction,  # Packed Indices
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.WritePackedPrimitiveIndices4x8NV,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpFetchMicroTriangleVertexPositionNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Accel
    y: SpirvInstruction,  # Instance Id
    z: SpirvInstruction,  # Geometry Index
    a: SpirvInstruction,  # Primitive Index
    b: SpirvInstruction,  # Barycentric
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FetchMicroTriangleVertexPositionNV,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpFetchMicroTriangleVertexBarycentricNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Accel
    y: SpirvInstruction,  # Instance Id
    z: SpirvInstruction,  # Geometry Index
    a: SpirvInstruction,  # Primitive Index
    b: SpirvInstruction,  # Barycentric
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FetchMicroTriangleVertexBarycentricNV,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeVectorLoadNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Offset
    z: Optional[MemoryAccess] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeVectorLoadNV,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeVectorStoreNV(
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Offset
    z: SpirvInstruction,  # Object
    a: Optional[MemoryAccess] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeVectorStoreNV,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )


def OpReportIntersectionKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit
    y: SpirvInstruction,  # HitKind
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReportIntersectionKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpReportIntersectionNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit
    y: SpirvInstruction,  # HitKind
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReportIntersectionKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpIgnoreIntersectionNV() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IgnoreIntersectionNV,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpTerminateRayNV() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TerminateRayNV,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpTraceNV(
    x: SpirvInstruction,  # Accel
    y: SpirvInstruction,  # Ray Flags
    z: SpirvInstruction,  # Cull Mask
    a: SpirvInstruction,  # SBT Offset
    b: SpirvInstruction,  # SBT Stride
    c: SpirvInstruction,  # Miss Index
    d: SpirvInstruction,  # Ray Origin
    e: SpirvInstruction,  # Ray Tmin
    f: SpirvInstruction,  # Ray Direction
    g: SpirvInstruction,  # Ray Tmax
    h: SpirvInstruction,  # PayloadId
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TraceNV,
        args=(x, y, z, a, b, c, d, e, f, g, h),
        hasresult=False,
        hasrtype=False,
    )


def OpTraceMotionNV(
    x: SpirvInstruction,  # Accel
    y: SpirvInstruction,  # Ray Flags
    z: SpirvInstruction,  # Cull Mask
    a: SpirvInstruction,  # SBT Offset
    b: SpirvInstruction,  # SBT Stride
    c: SpirvInstruction,  # Miss Index
    d: SpirvInstruction,  # Ray Origin
    e: SpirvInstruction,  # Ray Tmin
    f: SpirvInstruction,  # Ray Direction
    g: SpirvInstruction,  # Ray Tmax
    h: SpirvInstruction,  # Time
    i: SpirvInstruction,  # PayloadId
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TraceMotionNV,
        args=(x, y, z, a, b, c, d, e, f, g, h, i),
        hasresult=False,
        hasrtype=False,
    )


def OpTraceRayMotionNV(
    x: SpirvInstruction,  # Accel
    y: SpirvInstruction,  # Ray Flags
    z: SpirvInstruction,  # Cull Mask
    a: SpirvInstruction,  # SBT Offset
    b: SpirvInstruction,  # SBT Stride
    c: SpirvInstruction,  # Miss Index
    d: SpirvInstruction,  # Ray Origin
    e: SpirvInstruction,  # Ray Tmin
    f: SpirvInstruction,  # Ray Direction
    g: SpirvInstruction,  # Ray Tmax
    h: SpirvInstruction,  # Time
    i: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TraceRayMotionNV,
        args=(x, y, z, a, b, c, d, e, f, g, h, i),
        hasresult=False,
        hasrtype=False,
    )


def OpRayQueryGetIntersectionTriangleVertexPositionsKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionTriangleVertexPositionsKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpTypeAccelerationStructureKHR() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAccelerationStructureKHR,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAccelerationStructureNV() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAccelerationStructureKHR,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpExecuteCallableNV(
    x: SpirvInstruction,  # SBT Index
    y: SpirvInstruction,  # Callable DataId
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ExecuteCallableNV,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpRayQueryGetClusterIdNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetClusterIdNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetClusterIdNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetClusterIdNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpTypeCooperativeMatrixNV(
    x: SpirvInstruction,  # Component Type
    y: SpirvInstruction,  # Execution
    z: SpirvInstruction,  # Rows
    a: SpirvInstruction,  # Columns
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeCooperativeMatrixNV,
        args=(x, y, z, a),
        hasresult=True,
        hasrtype=False,
    )


def OpCooperativeMatrixLoadNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Stride
    z: SpirvInstruction,  # Column Major
    a: Optional[MemoryAccess] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixLoadNV,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeMatrixStoreNV(
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Object
    z: SpirvInstruction,  # Stride
    a: SpirvInstruction,  # Column Major
    b: Optional[MemoryAccess] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixStoreNV,
        args=(x, y, z, a, b),
        hasresult=False,
        hasrtype=False,
    )


def OpCooperativeMatrixMulAddNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: SpirvInstruction,  # B
    z: SpirvInstruction,  # C
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixMulAddNV,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeMatrixLengthNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Type
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixLengthNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpBeginInvocationInterlockEXT() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BeginInvocationInterlockEXT,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpEndInvocationInterlockEXT() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.EndInvocationInterlockEXT,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpCooperativeMatrixReduceNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Matrix
    y: CooperativeMatrixReduce,  # Reduce
    z: SpirvInstruction,  # CombineFunc
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixReduceNV,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeMatrixLoadTensorNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Object
    z: SpirvInstruction,  # TensorLayout
    a: MemoryAccess,  # Memory Operand
    b: TensorAddressingOperands,  # Tensor Addressing Operands
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixLoadTensorNV,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeMatrixStoreTensorNV(
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Object
    z: SpirvInstruction,  # TensorLayout
    a: MemoryAccess,  # Memory Operand
    b: TensorAddressingOperands,  # Tensor Addressing Operands
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixStoreTensorNV,
        args=(x, y, z, a, b),
        hasresult=False,
        hasrtype=False,
    )


def OpCooperativeMatrixPerElementOpNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Matrix
    y: SpirvInstruction,  # Func
    *z: SpirvInstruction,  # Operands
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixPerElementOpNV,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpTypeTensorLayoutNV(
    x: SpirvInstruction,  # Dim
    y: SpirvInstruction,  # ClampMode
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeTensorLayoutNV,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeTensorViewNV(
    x: SpirvInstruction,  # Dim
    y: SpirvInstruction,  # HasDimensions
    *z: SpirvInstruction,  # p
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeTensorViewNV,
        args=(x, y, z),
        hasresult=True,
        hasrtype=False,
    )


def OpCreateTensorLayoutNV(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CreateTensorLayoutNV,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpTensorLayoutSetDimensionNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # TensorLayout
    *y: SpirvInstruction,  # Dim
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorLayoutSetDimensionNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpTensorLayoutSetStrideNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # TensorLayout
    *y: SpirvInstruction,  # Stride
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorLayoutSetStrideNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpTensorLayoutSliceNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # TensorLayout
    *y: SpirvInstruction,  # Operands
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorLayoutSliceNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpTensorLayoutSetClampValueNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # TensorLayout
    y: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorLayoutSetClampValueNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpCreateTensorViewNV(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CreateTensorViewNV,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpTensorViewSetDimensionNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # TensorView
    *y: SpirvInstruction,  # Dim
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorViewSetDimensionNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpTensorViewSetStrideNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # TensorView
    *y: SpirvInstruction,  # Stride
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorViewSetStrideNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpDemoteToHelperInvocation() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DemoteToHelperInvocation,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpDemoteToHelperInvocationEXT() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DemoteToHelperInvocation,
        args=(),
        hasresult=False,
        hasrtype=False,
    )


def OpIsHelperInvocationEXT(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IsHelperInvocationEXT,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpTensorViewSetClipNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # TensorView
    y: SpirvInstruction,  # ClipRowOffset
    z: SpirvInstruction,  # ClipRowSpan
    a: SpirvInstruction,  # ClipColOffset
    b: SpirvInstruction,  # ClipColSpan
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorViewSetClipNV,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpTensorLayoutSetBlockSizeNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # TensorLayout
    *y: SpirvInstruction,  # BlockSize
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TensorLayoutSetBlockSizeNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpCooperativeMatrixTransposeNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Matrix
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CooperativeMatrixTransposeNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertUToImageNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertUToImageNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertUToSamplerNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertUToSamplerNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertImageToUNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertImageToUNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertSamplerToUNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertSamplerToUNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertUToSampledImageNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertUToSampledImageNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertSampledImageToUNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertSampledImageToUNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSamplerImageAddressingModeNV(
    x: int,  # Bit Width
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SamplerImageAddressingModeNV,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpRawAccessChainNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Base
    y: SpirvInstruction,  # Byte stride
    z: SpirvInstruction,  # Element index
    a: SpirvInstruction,  # Byte offset
    b: Optional[RawAccessChainOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RawAccessChainNV,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionSpherePositionNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionSpherePositionNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionSphereRadiusNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionSphereRadiusNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionLSSPositionsNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionLSSPositionsNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionLSSRadiiNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionLSSRadiiNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionLSSHitValueNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionLSSHitValueNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetSpherePositionNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetSpherePositionNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetSphereRadiusNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetSphereRadiusNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetLSSPositionsNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetLSSPositionsNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectGetLSSRadiiNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectGetLSSRadiiNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectIsSphereHitNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectIsSphereHitNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpHitObjectIsLSSHitNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Hit Object
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.HitObjectIsLSSHitNV,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryIsSphereHitNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryIsSphereHitNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryIsLSSHitNV(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryIsLSSHitNV,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupShuffleINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Data
    y: SpirvInstruction,  # InvocationId
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupShuffleINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupShuffleDownINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Current
    y: SpirvInstruction,  # Next
    z: SpirvInstruction,  # Delta
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupShuffleDownINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupShuffleUpINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Previous
    y: SpirvInstruction,  # Current
    z: SpirvInstruction,  # Delta
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupShuffleUpINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupShuffleXorINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Data
    y: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupShuffleXorINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupBlockReadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Ptr
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupBlockReadINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupBlockWriteINTEL(
    x: SpirvInstruction,  # Ptr
    y: SpirvInstruction,  # Data
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupBlockWriteINTEL,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpSubgroupImageBlockReadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupImageBlockReadINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupImageBlockWriteINTEL(
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # Data
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupImageBlockWriteINTEL,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpSubgroupImageMediaBlockReadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # Width
    a: SpirvInstruction,  # Height
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupImageMediaBlockReadINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupImageMediaBlockWriteINTEL(
    x: SpirvInstruction,  # Image
    y: SpirvInstruction,  # Coordinate
    z: SpirvInstruction,  # Width
    a: SpirvInstruction,  # Height
    b: SpirvInstruction,  # Data
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupImageMediaBlockWriteINTEL,
        args=(x, y, z, a, b),
        hasresult=False,
        hasrtype=False,
    )


def OpUCountLeadingZerosINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UCountLeadingZerosINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpUCountTrailingZerosINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UCountTrailingZerosINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpAbsISubINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AbsISubINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpAbsUSubINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AbsUSubINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpIAddSatINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IAddSatINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUAddSatINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UAddSatINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpIAverageINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IAverageINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUAverageINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UAverageINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpIAverageRoundedINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IAverageRoundedINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUAverageRoundedINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UAverageRoundedINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpISubSatINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ISubSatINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUSubSatINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.USubSatINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpIMul32x16INTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.IMul32x16INTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpUMul32x16INTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Operand 1
    y: SpirvInstruction,  # Operand 2
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.UMul32x16INTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpConstantFunctionPointerINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Function
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConstantFunctionPointerINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpFunctionPointerCallINTEL(
    rtype: SpirvInstruction,
    *x: SpirvInstruction,  # Operand 1
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FunctionPointerCallINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpAsmTargetINTEL(
    x: str,  # Asm target
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AsmTargetINTEL,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpAsmINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Asm type
    y: SpirvInstruction,  # Target
    z: str,  # Asm instructions
    a: str,  # Constraints
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AsmINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAsmCallINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Asm
    *y: SpirvInstruction,  # Argument
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AsmCallINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicFMinEXT(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicFMinEXT,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicFMaxEXT(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicFMaxEXT,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpAssumeTrueKHR(
    x: SpirvInstruction,  # Condition
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AssumeTrueKHR,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpExpectKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Value
    y: SpirvInstruction,  # ExpectedValue
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ExpectKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpDecorateString(
    x: SpirvInstruction,  # Target
    y: Decoration,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DecorateString,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpDecorateStringGOOGLE(
    x: SpirvInstruction,  # Target
    y: Decoration,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.DecorateString,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpMemberDecorateString(
    x: SpirvInstruction,  # Struct Type
    y: int,  # Member
    z: Decoration,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MemberDecorateString,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpMemberDecorateStringGOOGLE(
    x: SpirvInstruction,  # Struct Type
    y: int,  # Member
    z: Decoration,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MemberDecorateString,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpVmeImageINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image Type
    y: SpirvInstruction,  # Sampler
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.VmeImageINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpTypeVmeImageINTEL(
    x: SpirvInstruction,  # Image Type
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeVmeImageINTEL,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcImePayloadINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcImePayloadINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcRefPayloadINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcRefPayloadINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcSicPayloadINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcSicPayloadINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcMcePayloadINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcMcePayloadINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcMceResultINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcMceResultINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcImeResultINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcImeResultINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcImeResultSingleReferenceStreamoutINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcImeResultSingleReferenceStreamoutINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcImeResultDualReferenceStreamoutINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcImeResultDualReferenceStreamoutINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcImeSingleReferenceStreaminINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcImeSingleReferenceStreaminINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcImeDualReferenceStreaminINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcImeDualReferenceStreaminINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcRefResultINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcRefResultINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeAvcSicResultINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeAvcSicResultINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Slice Type
    y: SpirvInstruction,  # Qp
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Reference Base Penalty
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Slice Type
    y: SpirvInstruction,  # Qp
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultInterShapePenaltyINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceSetInterShapePenaltyINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Packed Shape Penalty
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceSetInterShapePenaltyINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Slice Type
    y: SpirvInstruction,  # Qp
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Direction Cost
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceSetInterDirectionPenaltyINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Slice Type
    y: SpirvInstruction,  # Qp
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Slice Type
    y: SpirvInstruction,  # Qp
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Packed Cost Center Delta
    y: SpirvInstruction,  # Packed Cost Table
    z: SpirvInstruction,  # Cost Precision
    a: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceSetMotionVectorCostFunctionINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Slice Type
    y: SpirvInstruction,  # Qp
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceSetAcOnlyHaarINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceSetAcOnlyHaarINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Source Field Polarity
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Reference Field Polarity
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Forward Reference Field Polarity
    y: SpirvInstruction,  # Backward Reference Field Polarity
    z: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceConvertToImePayloadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceConvertToImePayloadINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceConvertToImeResultINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceConvertToImeResultINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceConvertToRefPayloadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceConvertToRefPayloadINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceConvertToRefResultINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceConvertToRefResultINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceConvertToSicPayloadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceConvertToSicPayloadINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceConvertToSicResultINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceConvertToSicResultINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetMotionVectorsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetMotionVectorsINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetInterDistortionsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetInterDistortionsINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetBestInterDistortionsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetBestInterDistortionsINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetInterMajorShapeINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetInterMajorShapeINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetInterMinorShapeINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetInterMinorShapeINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetInterDirectionsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetInterDirectionsINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetInterMotionVectorCountINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetInterMotionVectorCountINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetInterReferenceIdsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetInterReferenceIdsINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Packed Reference Ids
    y: SpirvInstruction,  # Packed Reference Parameter Field Polarities
    z: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeInitializeINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Coord
    y: SpirvInstruction,  # Partition Mask
    z: SpirvInstruction,  # SAD Adjustment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeInitializeINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeSetSingleReferenceINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Ref Offset
    y: SpirvInstruction,  # Search Window Config
    z: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeSetSingleReferenceINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeSetDualReferenceINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Fwd Ref Offset
    y: SpirvInstruction,  # Bwd Ref Offset
    z: SpirvInstruction,  # Search Window Config
    a: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeSetDualReferenceINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeRefWindowSizeINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Search Window Config
    y: SpirvInstruction,  # Dual Ref
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeRefWindowSizeINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeAdjustRefOffsetINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Ref Offset
    y: SpirvInstruction,  # Src Coord
    z: SpirvInstruction,  # Ref Window Size
    a: SpirvInstruction,  # Image Size
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeAdjustRefOffsetINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeConvertToMcePayloadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeConvertToMcePayloadINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Max Motion Vector Count
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeSetMaxMotionVectorCountINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeSetUnidirectionalMixDisableINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Threshold
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeSetWeightedSadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Packed Sad Weights
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeSetWeightedSadINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Ref Image
    z: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeEvaluateWithSingleReferenceINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Fwd Ref Image
    z: SpirvInstruction,  # Bwd Ref Image
    a: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeEvaluateWithDualReferenceINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Ref Image
    z: SpirvInstruction,  # Payload
    a: SpirvInstruction,  # Streamin Components
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Fwd Ref Image
    z: SpirvInstruction,  # Bwd Ref Image
    a: SpirvInstruction,  # Payload
    b: SpirvInstruction,  # Streamin Components
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Ref Image
    z: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Fwd Ref Image
    z: SpirvInstruction,  # Bwd Ref Image
    a: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Ref Image
    z: SpirvInstruction,  # Payload
    a: SpirvInstruction,  # Streamin Components
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Fwd Ref Image
    z: SpirvInstruction,  # Bwd Ref Image
    a: SpirvInstruction,  # Payload
    b: SpirvInstruction,  # Streamin Components
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeConvertToMceResultINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeConvertToMceResultINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetSingleReferenceStreaminINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetDualReferenceStreaminINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetDualReferenceStreaminINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeStripSingleReferenceStreamoutINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeStripDualReferenceStreamoutINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
    y: SpirvInstruction,  # Major Shape
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
    y: SpirvInstruction,  # Major Shape
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
    y: SpirvInstruction,  # Major Shape
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
    y: SpirvInstruction,  # Major Shape
    z: SpirvInstruction,  # Direction
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
    y: SpirvInstruction,  # Major Shape
    z: SpirvInstruction,  # Direction
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
    y: SpirvInstruction,  # Major Shape
    z: SpirvInstruction,  # Direction
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetBorderReachedINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Image Select
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetBorderReachedINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetTruncatedSearchIndicationINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcFmeInitializeINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Coord
    y: SpirvInstruction,  # Motion Vectors
    z: SpirvInstruction,  # Major Shapes
    a: SpirvInstruction,  # Minor Shapes
    b: SpirvInstruction,  # Direction
    c: SpirvInstruction,  # Pixel Resolution
    d: SpirvInstruction,  # Sad Adjustment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcFmeInitializeINTEL,
        args=(rtype, x, y, z, a, b, c, d),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcBmeInitializeINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Coord
    y: SpirvInstruction,  # Motion Vectors
    z: SpirvInstruction,  # Major Shapes
    a: SpirvInstruction,  # Minor Shapes
    b: SpirvInstruction,  # Direction
    c: SpirvInstruction,  # Pixel Resolution
    d: SpirvInstruction,  # Bidirectional Weight
    e: SpirvInstruction,  # Sad Adjustment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcBmeInitializeINTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcRefConvertToMcePayloadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcRefConvertToMcePayloadINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcRefSetBidirectionalMixDisableINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcRefSetBilinearFilterEnableINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcRefSetBilinearFilterEnableINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Ref Image
    z: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcRefEvaluateWithSingleReferenceINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Fwd Ref Image
    z: SpirvInstruction,  # Bwd Ref Image
    a: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcRefEvaluateWithDualReferenceINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Packed Reference Ids
    z: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcRefEvaluateWithMultiReferenceINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Packed Reference Ids
    z: SpirvInstruction,  # Packed Reference Field Polarities
    a: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcRefConvertToMceResultINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcRefConvertToMceResultINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicInitializeINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Coord
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicInitializeINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicConfigureSkcINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Skip Block Partition Type
    y: SpirvInstruction,  # Skip Motion Vector Mask
    z: SpirvInstruction,  # Motion Vectors
    a: SpirvInstruction,  # Bidirectional Weight
    b: SpirvInstruction,  # Sad Adjustment
    c: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicConfigureSkcINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicConfigureIpeLumaINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Luma Intra Partition Mask
    y: SpirvInstruction,  # Intra Neighbour Availabilty
    z: SpirvInstruction,  # Left Edge Luma Pixels
    a: SpirvInstruction,  # Upper Left Corner Luma Pixel
    b: SpirvInstruction,  # Upper Edge Luma Pixels
    c: SpirvInstruction,  # Upper Right Edge Luma Pixels
    d: SpirvInstruction,  # Sad Adjustment
    e: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicConfigureIpeLumaINTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Luma Intra Partition Mask
    y: SpirvInstruction,  # Intra Neighbour Availabilty
    z: SpirvInstruction,  # Left Edge Luma Pixels
    a: SpirvInstruction,  # Upper Left Corner Luma Pixel
    b: SpirvInstruction,  # Upper Edge Luma Pixels
    c: SpirvInstruction,  # Upper Right Edge Luma Pixels
    d: SpirvInstruction,  # Left Edge Chroma Pixels
    e: SpirvInstruction,  # Upper Left Corner Chroma Pixel
    f: SpirvInstruction,  # Upper Edge Chroma Pixels
    g: SpirvInstruction,  # Sad Adjustment
    h: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicConfigureIpeLumaChromaINTEL,
        args=(rtype, x, y, z, a, b, c, d, e, f, g, h),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicGetMotionVectorMaskINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Skip Block Partition Type
    y: SpirvInstruction,  # Direction
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicGetMotionVectorMaskINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicConvertToMcePayloadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicConvertToMcePayloadINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Packed Shape Penalty
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicSetIntraLumaShapePenaltyINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Luma Mode Penalty
    y: SpirvInstruction,  # Luma Packed Neighbor Modes
    z: SpirvInstruction,  # Luma Packed Non Dc Penalty
    a: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Chroma Mode Base Penalty
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicSetBilinearFilterEnableINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicSetBilinearFilterEnableINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Packed Sad Coefficients
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicSetSkcForwardTransformEnableINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Block Based Skip Type
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicSetBlockBasedRawSkipSadINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicEvaluateIpeINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicEvaluateIpeINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Ref Image
    z: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicEvaluateWithSingleReferenceINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Fwd Ref Image
    z: SpirvInstruction,  # Bwd Ref Image
    a: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicEvaluateWithDualReferenceINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Packed Reference Ids
    z: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicEvaluateWithMultiReferenceINTEL,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Src Image
    y: SpirvInstruction,  # Packed Reference Ids
    z: SpirvInstruction,  # Packed Reference Field Polarities
    a: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicConvertToMceResultINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicConvertToMceResultINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicGetIpeLumaShapeINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicGetIpeLumaShapeINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicGetBestIpeLumaDistortionINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicGetBestIpeChromaDistortionINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicGetPackedIpeLumaModesINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicGetIpeChromaModeINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicGetIpeChromaModeINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSubgroupAvcSicGetInterRawSadsINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Payload
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupAvcSicGetInterRawSadsINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpVariableLengthArrayINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Lenght
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.VariableLengthArrayINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpSaveMemoryINTEL(
    rtype: SpirvInstruction,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SaveMemoryINTEL,
        args=(rtype,),
        hasresult=True,
        hasrtype=True,
    )


def OpRestoreMemoryINTEL(
    x: SpirvInstruction,  # Ptr
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RestoreMemoryINTEL,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpArbitraryFloatSinCosPiINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # MResult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # RoundingAccuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatSinCosPiINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatCastINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatCastINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatCastFromIntINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Mresult
    z: int,  # FromSign
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatCastFromIntINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatCastToIntINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # ToSign
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatCastToIntINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatAddINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
    b: int,  # MResult
    c: int,  # Subnormal
    d: int,  # Rounding
    e: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatAddINTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatSubINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
    b: int,  # Mresult
    c: int,  # Subnormal
    d: int,  # Rounding
    e: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatSubINTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatMulINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
    b: int,  # Mresult
    c: int,  # Subnormal
    d: int,  # Rounding
    e: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatMulINTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatDivINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
    b: int,  # Mresult
    c: int,  # Subnormal
    d: int,  # Rounding
    e: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatDivINTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatGTINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatGTINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatGEINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatGEINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatLTINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatLTINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatLEINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatLEINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatEQINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatEQINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatRecipINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatRecipINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatRSqrtINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatRSqrtINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatCbrtINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatCbrtINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatHypotINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
    b: int,  # Mresult
    c: int,  # Subnormal
    d: int,  # Rounding
    e: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatHypotINTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatSqrtINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatSqrtINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatLogINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatLogINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatLog2INTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatLog2INTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatLog10INTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatLog10INTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatLog1pINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatLog1pINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatExpINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatExpINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatExp2INTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatExp2INTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatExp10INTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatExp10INTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatExpm1INTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatExpm1INTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatSinINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatSinINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatCosINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatCosINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatSinCosINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatSinCosINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatSinPiINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatSinPiINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatCosPiINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatCosPiINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatASinINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatASinINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatASinPiINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatASinPiINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatACosINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # M1
    z: int,  # Mout
    a: int,  # EnableSubnormals
    b: int,  # RoundingMode
    c: int,  # RoundingAccuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatACosINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatACosPiINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatACosPiINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatATanINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatATanINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatATanPiINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: int,  # Mresult
    a: int,  # Subnormal
    b: int,  # Rounding
    c: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatATanPiINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatATan2INTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
    b: int,  # Mresult
    c: int,  # Subnormal
    d: int,  # Rounding
    e: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatATan2INTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatPowINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
    b: int,  # Mresult
    c: int,  # Subnormal
    d: int,  # Rounding
    e: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatPowINTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatPowRINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # Mb
    b: int,  # Mresult
    c: int,  # Subnormal
    d: int,  # Rounding
    e: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatPowRINTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpArbitraryFloatPowNINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: int,  # Ma
    z: SpirvInstruction,  # B
    a: int,  # SignOfB
    b: int,  # Mresult
    c: int,  # Subnormal
    d: int,  # Rounding
    e: int,  # Accuracy
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArbitraryFloatPowNINTEL,
        args=(rtype, x, y, z, a, b, c, d, e),
        hasresult=True,
        hasrtype=True,
    )


def OpLoopControlINTEL(
    *x: int,  # Loop Control Parameters
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.LoopControlINTEL,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpAliasDomainDeclINTEL(
    x: Optional[SpirvInstruction] = None,  # Name
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AliasDomainDeclINTEL,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpAliasScopeDeclINTEL(
    x: SpirvInstruction,  # Alias Domain
    y: Optional[SpirvInstruction] = None,  # Name
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AliasScopeDeclINTEL,
        args=(x, y),
        hasresult=True,
        hasrtype=False,
    )


def OpAliasScopeListDeclINTEL(
    *x: SpirvInstruction,  # AliasScope 1, AliasScope 2, ...
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AliasScopeListDeclINTEL,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpFixedSqrtINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedSqrtINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpFixedRecipINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedRecipINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpFixedRsqrtINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedRsqrtINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpFixedSinINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedSinINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpFixedCosINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedCosINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpFixedSinCosINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedSinCosINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpFixedSinPiINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedSinPiINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpFixedCosPiINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedCosPiINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpFixedSinCosPiINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedSinCosPiINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpFixedLogINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedLogINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpFixedExpINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
    y: int,  # S
    z: int,  # I
    a: int,  # rI
    b: int,  # Q
    c: int,  # O
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FixedExpINTEL,
        args=(rtype, x, y, z, a, b, c),
        hasresult=True,
        hasrtype=True,
    )


def OpPtrCastToCrossWorkgroupINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.PtrCastToCrossWorkgroupINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpCrossWorkgroupCastToPtrINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CrossWorkgroupCastToPtrINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpReadPipeBlockingINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Packet Size
    y: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ReadPipeBlockingINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpWritePipeBlockingINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Packet Size
    y: SpirvInstruction,  # Packet Alignment
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.WritePipeBlockingINTEL,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpFPGARegINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Input
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.FPGARegINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetRayTMinKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetRayTMinKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetRayFlagsKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetRayFlagsKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionTKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionTKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionInstanceCustomIndexKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionInstanceCustomIndexKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionInstanceIdKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionInstanceIdKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionGeometryIndexKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionGeometryIndexKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionPrimitiveIndexKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionPrimitiveIndexKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionBarycentricsKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionBarycentricsKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionFrontFaceKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionFrontFaceKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionCandidateAABBOpaqueKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionObjectRayDirectionKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionObjectRayDirectionKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionObjectRayOriginKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionObjectRayOriginKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetWorldRayDirectionKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetWorldRayDirectionKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetWorldRayOriginKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetWorldRayOriginKHR,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionObjectToWorldKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionObjectToWorldKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpRayQueryGetIntersectionWorldToObjectKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # RayQuery
    y: SpirvInstruction,  # Intersection
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RayQueryGetIntersectionWorldToObjectKHR,
        args=(rtype, x, y),
        hasresult=True,
        hasrtype=True,
    )


def OpAtomicFAddEXT(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Pointer
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
    a: SpirvInstruction,  # Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.AtomicFAddEXT,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpTypeBufferSurfaceINTEL(
    x: AccessQualifier,  # AccessQualifier
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeBufferSurfaceINTEL,
        args=(x,),
        hasresult=True,
        hasrtype=False,
    )


def OpTypeStructContinuedINTEL(
    *x: SpirvInstruction,  # Member 0 type, member 1 type, ...
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeStructContinuedINTEL,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpConstantCompositeContinuedINTEL(
    *x: SpirvInstruction,  # Constituents
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConstantCompositeContinuedINTEL,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpSpecConstantCompositeContinuedINTEL(
    *x: SpirvInstruction,  # Constituents
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SpecConstantCompositeContinuedINTEL,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpCompositeConstructContinuedINTEL(
    rtype: SpirvInstruction,
    *x: SpirvInstruction,  # Constituents
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.CompositeConstructContinuedINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertFToBF16INTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Float Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertFToBF16INTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpConvertBF16ToFINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # BFloat16 Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ConvertBF16ToFINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpControlBarrierArriveINTEL(
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ControlBarrierArriveINTEL,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpControlBarrierWaitINTEL(
    x: SpirvInstruction,  # Execution
    y: SpirvInstruction,  # Memory
    z: SpirvInstruction,  # Semantics
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ControlBarrierWaitINTEL,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpArithmeticFenceEXT(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Target
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.ArithmeticFenceEXT,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpTaskSequenceCreateINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Function
    y: int,  # Pipelined
    z: int,  # UseStallEnableClusters
    a: int,  # GetCapacity
    b: int,  # AsyncCapacity
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TaskSequenceCreateINTEL,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpTaskSequenceAsyncINTEL(
    x: SpirvInstruction,  # Sequence
    *y: SpirvInstruction,  # Arguments
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TaskSequenceAsyncINTEL,
        args=(x, y),
        hasresult=False,
        hasrtype=False,
    )


def OpTaskSequenceGetINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Sequence
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TaskSequenceGetINTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpTaskSequenceReleaseINTEL(
    x: SpirvInstruction,  # Sequence
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TaskSequenceReleaseINTEL,
        args=(x,),
        hasresult=False,
        hasrtype=False,
    )


def OpTypeTaskSequenceINTEL() -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.TypeTaskSequenceINTEL,
        args=(),
        hasresult=True,
        hasrtype=False,
    )


def OpSubgroupBlockPrefetchINTEL(
    x: SpirvInstruction,  # Ptr
    y: SpirvInstruction,  # NumBytes
    z: Optional[MemoryAccess] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupBlockPrefetchINTEL,
        args=(x, y, z),
        hasresult=False,
        hasrtype=False,
    )


def OpSubgroup2DBlockLoadINTEL(
    x: SpirvInstruction,  # Element Size
    y: SpirvInstruction,  # Block Width
    z: SpirvInstruction,  # Block Height
    a: SpirvInstruction,  # Block Count
    b: SpirvInstruction,  # Src Base Pointer
    c: SpirvInstruction,  # Memory Width
    d: SpirvInstruction,  # Memory Height
    e: SpirvInstruction,  # Memory Pitch
    f: SpirvInstruction,  # Coordinate
    g: SpirvInstruction,  # Dst Pointer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Subgroup2DBlockLoadINTEL,
        args=(x, y, z, a, b, c, d, e, f, g),
        hasresult=False,
        hasrtype=False,
    )


def OpSubgroup2DBlockLoadTransformINTEL(
    x: SpirvInstruction,  # Element Size
    y: SpirvInstruction,  # Block Width
    z: SpirvInstruction,  # Block Height
    a: SpirvInstruction,  # Block Count
    b: SpirvInstruction,  # Src Base Pointer
    c: SpirvInstruction,  # Memory Width
    d: SpirvInstruction,  # Memory Height
    e: SpirvInstruction,  # Memory Pitch
    f: SpirvInstruction,  # Coordinate
    g: SpirvInstruction,  # Dst Pointer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Subgroup2DBlockLoadTransformINTEL,
        args=(x, y, z, a, b, c, d, e, f, g),
        hasresult=False,
        hasrtype=False,
    )


def OpSubgroup2DBlockLoadTransposeINTEL(
    x: SpirvInstruction,  # Element Size
    y: SpirvInstruction,  # Block Width
    z: SpirvInstruction,  # Block Height
    a: SpirvInstruction,  # Block Count
    b: SpirvInstruction,  # Src Base Pointer
    c: SpirvInstruction,  # Memory Width
    d: SpirvInstruction,  # Memory Height
    e: SpirvInstruction,  # Memory Pitch
    f: SpirvInstruction,  # Coordinate
    g: SpirvInstruction,  # Dst Pointer
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Subgroup2DBlockLoadTransposeINTEL,
        args=(x, y, z, a, b, c, d, e, f, g),
        hasresult=False,
        hasrtype=False,
    )


def OpSubgroup2DBlockPrefetchINTEL(
    x: SpirvInstruction,  # Element Size
    y: SpirvInstruction,  # Block Width
    z: SpirvInstruction,  # Block Height
    a: SpirvInstruction,  # Block Count
    b: SpirvInstruction,  # Src Base Pointer
    c: SpirvInstruction,  # Memory Width
    d: SpirvInstruction,  # Memory Height
    e: SpirvInstruction,  # Memory Pitch
    f: SpirvInstruction,  # Coordinate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Subgroup2DBlockPrefetchINTEL,
        args=(x, y, z, a, b, c, d, e, f),
        hasresult=False,
        hasrtype=False,
    )


def OpSubgroup2DBlockStoreINTEL(
    x: SpirvInstruction,  # Element Size
    y: SpirvInstruction,  # Block Width
    z: SpirvInstruction,  # Block Height
    a: SpirvInstruction,  # Block Count
    b: SpirvInstruction,  # Src Pointer
    c: SpirvInstruction,  # Dst Base Pointer
    d: SpirvInstruction,  # Memory Width
    e: SpirvInstruction,  # Memory Height
    f: SpirvInstruction,  # Memory Pitch
    g: SpirvInstruction,  # Coordinate
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.Subgroup2DBlockStoreINTEL,
        args=(x, y, z, a, b, c, d, e, f, g),
        hasresult=False,
        hasrtype=False,
    )


def OpSubgroupMatrixMultiplyAccumulateINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # K Dim
    y: SpirvInstruction,  # Matrix A
    z: SpirvInstruction,  # Matrix B
    a: SpirvInstruction,  # Matrix C
    b: Optional[MatrixMultiplyAccumulateOperands] = None,
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.SubgroupMatrixMultiplyAccumulateINTEL,
        args=(rtype, x, y, z, a, b),
        hasresult=True,
        hasrtype=True,
    )


def OpBitwiseFunctionINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # A
    y: SpirvInstruction,  # B
    z: SpirvInstruction,  # C
    a: SpirvInstruction,  # LUTIndex
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.BitwiseFunctionINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupIMulKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupIMulKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupFMulKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupFMulKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupBitwiseAndKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupBitwiseAndKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupBitwiseOrKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupBitwiseOrKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupBitwiseXorKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupBitwiseXorKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupLogicalAndKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupLogicalAndKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupLogicalOrKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupLogicalOrKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpGroupLogicalXorKHR(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Execution
    y: GroupOperation,  # Operation
    z: SpirvInstruction,  # X
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.GroupLogicalXorKHR,
        args=(rtype, x, y, z),
        hasresult=True,
        hasrtype=True,
    )


def OpRoundFToTF32INTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # Float Value
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.RoundFToTF32INTEL,
        args=(rtype, x),
        hasresult=True,
        hasrtype=True,
    )


def OpMaskedGatherINTEL(
    rtype: SpirvInstruction,
    x: SpirvInstruction,  # PtrVector
    y: int,  # Alignment
    z: SpirvInstruction,  # Mask
    a: SpirvInstruction,  # FillEmpty
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MaskedGatherINTEL,
        args=(rtype, x, y, z, a),
        hasresult=True,
        hasrtype=True,
    )


def OpMaskedScatterINTEL(
    x: SpirvInstruction,  # InputVector
    y: SpirvInstruction,  # PtrVector
    z: int,  # Alignment
    a: SpirvInstruction,  # Mask
) -> SpirvInstruction:
    return SpirvInstruction(
        opcode=Op.MaskedScatterINTEL,
        args=(x, y, z, a),
        hasresult=False,
        hasrtype=False,
    )
